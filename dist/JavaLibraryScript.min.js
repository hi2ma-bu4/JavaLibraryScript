!function t(e,r,s){function n(o,a){if(!r[o]){if(!e[o]){var c="function"==typeof require&&require;if(!a&&c)return c(o,!0);if(i)return i(o,!0);var u=new Error("Cannot find module '"+o+"'");throw u.code="MODULE_NOT_FOUND",u}var h=r[o]={exports:{}};e[o][0].call(h.exports,(function(t){return n(e[o][1][t]||t)}),h,h.exports,t,e,r,s)}return r[o].exports}for(var i="function"==typeof require&&require,o=0;o<s.length;o++)n(s[o]);return n}({1:[function(t,e,r){const s=t("../libs/sys/JavaLibraryScriptCore");class n extends s{constructor(t,e,r=t,s=null,n={}){super(),this.name=t,this.ordinal=e,this.value=r,this.owner=s;for(const[t,e]of Object.entries(n))"function"==typeof e&&(this[t]=e.bind(this));Object.freeze(this)}toString(){return this.name}toJSON(){return this.name}compareTo(t){return this.ordinal-t.ordinal}equals(t){return t instanceof n&&this.name===t.name&&this.ordinal===t.ordinal&&this.value===t.value}hashCode(){return this.name.split("").reduce(((t,e)=>t+e.charCodeAt(0)),0)+31*this.ordinal}}class i extends s{constructor(t,e={}){let r;if(super(),this._items=[],this._methods=e.methods||{},Array.isArray(t))r=t.map((t=>Array.isArray(t)?t:[t,t]));else{if("object"!=typeof t||null===t)throw new TypeError("Enum: 配列か連想配列で定義してください");r=Object.entries(t)}r.forEach((([t,e],r)=>{const s=new n(t,r,e,this,this._methods);Object.defineProperty(this,t,{value:s,writable:!1,configurable:!1,enumerable:!0}),this._items.push(s)})),Object.freeze(this._items)}values(){return this._items.slice()}valueOf(t){return this[t]}fromName=valueOf;fromValue(t){return this._items.find((e=>e.value===t))}fromOrdinal(t){return this._items.find((e=>e.ordinal===t))}has(t){return"object"==typeof this[t]&&this[t]instanceof n}entries(){return this._items.map((t=>[t.name,t]))}keys(){return this._items.map((t=>t.name))}toMap(){const t={};for(const e of this._items)t[e.name]=e.value;return t}toJSON(){return this._items.map((t=>t.toJSON()))}*[Symbol.iterator](){yield*this._items}*enumerate(){for(let t=0;t<this._items.length;t++)yield[t,this._items[t]]}}e.exports={_EnumItem:n,_EnumCore:i,Enum:function(t,e={}){const r=new i(t,e);return new Proxy(r,{get(t,e,r){if("string"==typeof e&&/^[0-9]+$/.test(e)){const r=Number(e);return t._items[r]}return Reflect.get(t,e,r)},enumerate:t=>Object.keys(t._items).map((t=>t.toString())),has(t,e){if("string"==typeof e&&/^[0-9]+$/.test(e)){const r=Number(e);return r>=0&&r<t._items.length}return e in t},ownKeys:t=>[...Reflect.ownKeys(t),...t._items.map(((t,e)=>e.toString()))],getOwnPropertyDescriptor:(t,e)=>"string"==typeof e&&/^[0-9]+$/.test(e)?e in t._items?{value:t._items[Number(e)],writable:!1,configurable:!1,enumerable:!0}:void 0:Object.getOwnPropertyDescriptor(t,e),set(t,e,r){throw new TypeError(`Enumは変更できません: ${String(e)} = ${r}`)},defineProperty(t,e,r){throw new TypeError(`Enumにプロパティを追加/変更できません: ${String(e)}`)},deleteProperty(t,e){throw new TypeError(`Enumのプロパティを削除できません: ${String(e)}`)}})}}},{"../libs/sys/JavaLibraryScriptCore":9}],2:[function(t,e,r){const s=t("../libs/sys/JavaLibraryScriptCore"),n=t("../libs/TypeChecker"),{_EnumItem:i,Enum:o}=t("./Enum");class a extends s{static _isDebugMode=!1;static ErrorMode=o(["throw","log","ignore"]);static _errorMode=this.ErrorMode.throw;static setErrorMode(t){if(!this.ErrorMode.has(t))throw new Error(`不正な errorMode: ${t}`);this._errorMode=t}static _handleError(t,e){const r=this.ErrorMode;switch(this._errorMode){case r.throw:throw new t(e);case r.log:case r.ignore:}}static applyTo(t,e={},{inherit:r=!0}={}){const s=t.prototype;let n={};if(r){const t=Object.getPrototypeOf(s);t&&t.__interfaceTypes&&(n={...t.__interfaceTypes})}s.__interfaceTypes||Object.defineProperty(s,"__interfaceTypes",{value:{},configurable:!1,writable:!1,enumerable:!1}),Object.assign(s.__interfaceTypes,n,e)}static convert(t,e={},{inherit:r=!0,abstract:s=!0}={}){this.applyTo(t,e,{inherit:r});const i=this,o=class extends t{constructor(...e){if(s&&new.target===o&&new TypeError(`Cannot instantiate abstract class ${t.name}`),super(...e),!a._isDebugMode)return;const r=Object.getPrototypeOf(this).__interfaceTypes||{};for(const t of Object.keys(r)){const e=r[t],s=this[t],o=!!e.abstract;if("function"!=typeof s){if(o)continue;return void i._handleError(Error,`"${this.constructor.name}" はメソッド "${t}" を実装する必要があります`)}if(!s.__isWrapped){const r=(...r)=>{const o=e.args||[];for(let e=0;e<o.length;e++)n.matchType(r[e],o[e])||i._handleError(TypeError,`"${this.constructor.name}.${t}" 第${e+1}引数: ${n.typeNames(o[e])} を期待 → 実際: ${n.stringify(r[e])}`);const a=s.apply(this,r),c=n.checkFunction(e.returns)?e.returns(r):e.returns,u=e=>(n.matchType(e,c)||(c===n.NoReturn?i._handleError(TypeError,`"${this.constructor.name}.${t}" は戻り値を返してはいけません → 実際: ${n.stringify(e)}`):i._handleError(TypeError,`"${this.constructor.name}.${t}" の戻り値: ${n.typeNames(c)} を期待 → 実際: ${n.stringify(e)}`)),e);return a instanceof Promise?a.then(u):u(a)};r.__isWrapped=!0,this[t]=r}}}};return Object.defineProperty(o,"name",{value:t.name}),o}static isAbstractImplemented(t){const e=Object.getPrototypeOf(t).__interfaceTypes||{};for(const[r,s]of Object.entries(e))if(s.abstract&&"function"!=typeof t[r])return!1;return!0}static getDefinition(t){return("function"==typeof t?t.prototype:Object.getPrototypeOf(t)).__interfaceTypes||{}}static describe(t){const e=this.getDefinition(t),r=[];for(const[t,s]of Object.entries(e)){const e=(s.args||[]).map((t=>n.typeNames(t))).join(", "),i=n.typeNames(s.returns);r.push(`${s.abstract?"abstract ":""}function ${t}(${e}) → ${i}`)}return r.join("\n")}static getMethodNames(t,{abstractOnly:e=!1}={}){const r=this.getDefinition(t);return Object.entries(r).filter((([t,r])=>!e||r.abstract)).map((([t])=>t))}static getExpectedSignature(t,e){const r=this.getDefinition(t);return e in r?{args:r[e].args,returns:r[e].returns,abstract:!!r[e].abstract}:null}static merge(...t){const e={};for(const r of t)Object.assign(e,r);return e}}e.exports=a},{"../libs/TypeChecker":7,"../libs/sys/JavaLibraryScriptCore":9,"./Enum":1}],3:[function(t,e,r){e.exports={...t("./Enum.js"),Interface:t("./Interface.js")}},{"./Enum.js":1,"./Interface.js":2}],4:[function(t,e,r){e.exports={base:t("./base/index.js"),libs:t("./libs/index.js"),math:t("./math/index.js"),util:t("./util/index.js")}},{"./base/index.js":3,"./libs/index.js":8,"./math/index.js":15,"./util/index.js":22}],5:[function(t,e,r){const s=t("./sys/symbol/SymbolDict"),n=t("./sys/JavaLibraryScriptCore"),i=t("./ProxyManager"),o=t("./TypeChecker"),a=s.instanceofTarget;e.exports=class extends n{constructor(t,{getMethod:e="get",setMethod:r="set",sizeMethod:s="size",addMethod:n="add",typeCheckMethod:i=null,autoExtend:o=!0}={}){super(),this._TargetClass=t,this._config={getMethod:e,setMethod:r,sizeMethod:s,addMethod:n,typeCheckMethod:i,autoExtend:o},this._cachedMethods={get:null,set:null,size:null,add:null,typeCheck:null}}create(...t){const e=new this._TargetClass(...t),r=o.typeNames(this._TargetClass),s=this._config,n=this._cachedMethods;if("function"!=typeof e[s.getMethod])throw new TypeError(`${r}.${s.getMethod}(index) メソッドが必要です。`);if("function"!=typeof e[s.setMethod])throw new TypeError(`${r}.${s.setMethod}(index, value) メソッドが必要です。`);n.get=e[s.getMethod].bind(e),n.set=e[s.setMethod].bind(e);const a=e[s.sizeMethod];if("function"==typeof a)n.size=a.bind(e);else{if("number"!=typeof a)throw new TypeError(`${r}.${s.sizeMethod}() メソッドまたは、${r}.${s.sizeMethod} getterが必要です。`);n.size=()=>e[s.sizeMethod]}if("function"==typeof e[s.addMethod])n.add=e[s.addMethod].bind(e);else if(this._config.autoExtend)throw new TypeError(`${this._TargetClass}.${s.addMethod}(item) メソッドが必要です。範囲外追加を許容しない場合はautoExtendをfalseにしてください。`);return"function"==typeof e[s.typeCheckMethod]&&(n.typeCheck=e[s.typeCheckMethod].bind(e)),new Proxy(e,{get:(t,e,r)=>isNaN(e)?i.over_get(t,e,r):n.get(Number(e)),set:(t,e,r,s)=>{if(!isNaN(e)){const t=Number(e);n.typeCheck&&n.typeCheck(r);const s=n.size();if(t<s)n.set(t,r);else{if(t!==s||!this._config.autoExtend)throw new RangeError(`インデックス ${t} は無効です（サイズ: ${s}）`);n.add(r)}return!0}return Reflect.set(t,e,r,s)},has:(t,e)=>{if(!isNaN(e)){const t=Number(e),r=n.size();return t>=0&&t<r}return e in t}})}static defineInitData(t){Object.defineProperty(t,a,{value:t,enumerable:!1,writable:!1})}static hasInstance(t,e){const r=e?.[a];return"object"==typeof r&&null!==r&&t.prototype.isPrototypeOf(r)}}},{"./ProxyManager":6,"./TypeChecker":7,"./sys/JavaLibraryScriptCore":9,"./sys/symbol/SymbolDict":11}],6:[function(t,e,r){const s=t("./sys/JavaLibraryScriptCore");e.exports=class extends s{static over_get(t,e,r){return"toString"===e?()=>`Proxy(${t.toString()})`:Reflect.get(t,e,r)}}},{"./sys/JavaLibraryScriptCore":9}],7:[function(t,e,r){const s=t("../libs/sys/symbol/SymbolDict"),n=t("../libs/sys/JavaLibraryScriptCore"),{_EnumCore:i,_EnumItem:o}=t("../base/Enum");class a extends n{static _CLASS_REG=/^\s*class\s+/;static _NotType=class extends n{constructor(t){if(super(),t instanceof a._NotType)throw new TypeError("typeToExclude must be instance of NotType");this.typeToExclude=t}};static NotType(t){return new a._NotType(t)}static Any=s.TypeAny;static Void=s.TypeVoid;static NoReturn=this.Void;static NotNull=this.NotType(null);static NotUndefined=this.NotType(void 0);static matchType(t,e){if(Array.isArray(e)){if(e.filter((t=>t instanceof this._NotType)).some((e=>this.checkType(t,e.typeToExclude))))return!1;const r=e.filter((t=>!(t instanceof this._NotType)));return 0===r.length||r.some((e=>this.checkType(t,e)))}return this.checkType(t,e)}static checkType(t,e){return e instanceof this._NotType?!this.checkType(t,e.typeToExclude):e===this.Any||(e===this.NoReturn?void 0===t:null===e?null===t:void 0===e?void 0===t:e===String||e===Number||e===Boolean||e===Symbol||e===Function||e===BigInt?typeof t===e.name.toLowerCase():e===Object?"object"==typeof t&&null!==t&&!Array.isArray(t):e===Array?Array.isArray(t):e instanceof i?e.has(t?.name):e===o?t instanceof o:"function"==typeof e&&t instanceof e)}static getType(t){if(null===t)return null;if(void 0===t)return;const e=typeof t;switch(e){case"string":return String;case"number":return Number;case"boolean":return Boolean;case"symbol":return Symbol;case"function":return Function;case"bigint":return BigInt;case"object":return Array.isArray(t)?Array:t.constructor}throw new TypeError(`TypeChecker: getType()に対応していない型:${e}`)}static typeNames(t){return Array.isArray(t)?t.map((t=>t?.name||a.stringify(t))).join(" | "):t?.name||a.stringify(t)}static stringify(t){if(null==t)return String(t);if("symbol"==typeof t)switch(t){case this.Any:return"Any";case this.NoReturn:case this.Void:return"NoReturn"}if("object"==typeof t){if("[object Object]"!==t?.toString())return String(t);if(t instanceof this._NotType)return`NotType(${a.stringify(t.typeToExclude)})`;try{const e=JSON.stringify(t,((t,e)=>{if(e&&"object"==typeof e){const t=Object.keys(e).length;if(t>5)return`Object with ${t} properties`}return e}),0);return void 0===e?"Object is too large to display or contains circular references":e.length>1e3?"Object is too large to display":e}catch(t){return`[オブジェクト表示エラー: ${t.message}]`}}return String(t)}static checkFunction(t){return"function"==typeof t&&!this.checkClass(t)}static checkClass(t){if("function"!=typeof t)return!1;if(this._CLASS_REG.test(t.toString()))return!0;if(t===Function)return!0;try{return new new Proxy(t,{construct:()=>({})}),!0}catch{return!1}}}e.exports=a},{"../base/Enum":1,"../libs/sys/JavaLibraryScriptCore":9,"../libs/sys/symbol/SymbolDict":11}],8:[function(t,e,r){e.exports={IndexProxy:t("./IndexProxy.js"),ProxyManager:t("./ProxyManager.js"),TypeChecker:t("./TypeChecker.js"),sys:t("./sys/index.js")}},{"./IndexProxy.js":5,"./ProxyManager.js":6,"./TypeChecker.js":7,"./sys/index.js":10}],9:[function(t,e,r){const s=t("./symbol/SymbolDict");class n{static[s.JavaLibraryScript]=!0}e.exports=n},{"./symbol/SymbolDict":11}],10:[function(t,e,r){e.exports={JavaLibraryScriptCore:t("./JavaLibraryScriptCore.js"),symbol:t("./symbol/index.js")}},{"./JavaLibraryScriptCore.js":9,"./symbol/index.js":12}],11:[function(t,e,r){const s="@@JLS_",n={JavaLibraryScript:Symbol.for(`${s}JavaLibraryScript`),instanceofTarget:Symbol.for(`${s}instanceofTarget`),TypeAny:Symbol("Any"),TypeVoid:Symbol("Void")};e.exports=n},{}],12:[function(t,e,r){e.exports={...t("./SymbolDict.js")}},{"./SymbolDict.js":11}],13:[function(t,e,r){const s=t("./index");"undefined"!=typeof window&&(window.JavaLibraryScript=s),e.exports=s},{"./index":4}],14:[function(t,e,r){const s=t("../libs/sys/JavaLibraryScriptCore");class n extends s{static ROUND_TRUNCATE=0;static ROUND_DOWN=0;static ROUND_UP=1;static ROUND_CEIL=2;static ROUND_FLOOR=3;static ROUND_HALF_UP=4;static ROUND_HALF_DOWN=5;static PI_MATH_DEFAULT=0;static PI_LEIBNIZ=1;static PI_NEWTON=2;static PI_CHUDNOVSKY=3;constructor({allowPrecisionMismatch:t=!1,roundingMode:e=n.ROUND_TRUNCATE,extraPrecision:r=1n,piAlgorithm:s=n.PI_CHUDNOVSKY,sqrtMaxNewtonSteps:i=50,sqrtMaxChebyshevSteps:o=30}={}){super(),this.allowPrecisionMismatch=t,this.roundingMode=e,this.extraPrecision=r,this.piAlgorithm=s,this.sqrtMaxNewtonSteps=i,this.sqrtMaxChebyshevSteps=o}clone(){return new n({...this})}toggleMismatch(){this.allowPrecisionMismatch=!this.allowPrecisionMismatch}}class i extends s{static MAX_PRECISION=200000000n;static config=new n;constructor(t,e=20n){if(super(),t instanceof i)return void(this.value=t.value);this._precision=BigInt(e);const r=this.constructor;if(r._checkMaxPrecision(this._precision),!t)return void(this.value=0n);const{intPart:s,fracPart:n,sign:o}=this._parse(t),a=this._precision+r.config.extraPrecision,c=n.padEnd(Number(a),"0").slice(0,Number(a)),u=BigInt(s+c)*BigInt(o);this.value=r._round(u,a,this._precision)}static clone(){const t=this;return class extends t{static config=t.config.clone();static MAX_PRECISION=t.MAX_PRECISION}}toString(){return this._normalize(this.value)}toNumber(){return Number(this.toString())}static _checkMaxPrecision(t){if(t>this.MAX_PRECISION)throw new RangeError(`Precision exceeds ${this.name}.MAX_PRECISION`)}_parse(t){const[e,r=""]=t.toString().split("."),s=e.startsWith("-")?-1:1;return{intPart:e.replace("-",""),fracPart:r,sign:s}}_normalize(t){const e=t<0n?"-":"",r=t<0n?-t:t,s=Number(this._precision);if(0===s)return`${e}${r.toString()}`;const n=r.toString().padStart(s+1,"0");return`${e}${n.slice(0,-s)}.${n.slice(-s)}`}_rescaleToMatch(t,e=!1){const r=this._precision,s=t._precision,n=this.constructor.config;if(r===s){if(e){const e=n.extraPrecision,s=10n**e;return[this.value*s,t.value*s,r+e,r]}return[this.value,t.value,r,r]}if(!n.allowPrecisionMismatch)throw new Error("Precision mismatch");const i=r>s?r:s,o=i+(e?n.extraPrecision:0n),a=o-r,c=o-s;return[this.value*10n**a,t.value*10n**c,o,i]}static _makeResult(t,e,r=e){const s=this._round(t,r,e),n=new this;return n._precision=e,n.value=s,n}_makeResult(t,e,r=e){return this.constructor._makeResult(t,e,r)}static _round(t,e,r){const s=e-r;if(s<0n)return 0n===s?t:t*10n**-s;const i=10n**s,o=t%i,a=t-o;if(0n===o)return a/i;const c=o<0n?-o:o,u=i/2n,h=t<0n;let l=0n;switch(this.config.roundingMode){case n.ROUND_UP:l=h?-i:i;break;case n.ROUND_CEIL:h||(l=i);break;case n.ROUND_FLOOR:h&&(l=-i);break;case n.ROUND_HALF_UP:c>=u&&(l=h?-i:i);break;case n.ROUND_HALF_DOWN:c>u&&(l=h?-i:i)}return(a+l)/i}static piLeibniz(t=20n,e=100n){t=BigInt(t),this._checkMaxPrecision(t),e=BigInt(e);const r=t+this.config.extraPrecision,s=r*e;let n=0n;const i=4n*10n**r;let o=0n;for(let t=0n;t<s;t++){const e=i/(2n*t+1n);if(e===o)break;o=e,n+=t%2n==0n?e:-e}return this._makeResult(n,t,r)}static piNewton(t=20n,e=5n){t=BigInt(t),this._checkMaxPrecision(t),e=BigInt(e);const r=t+this.config.extraPrecision*e,s=10n**r;function n(t){const e=s/t,r=e*e/s;let n=e,i=n,o=-1n,a=3n,c=0n;for(;n=n*r/s,n!==c;)c=n,i+=o*n/a,o=-o,a+=2n;return i}const i=16n*n(5n)-4n*n(239n);return this._makeResult(i,t,r)}static _sqrtBigInt(t,e){const r=t*10n**e;let s,n=r;for(;s=n,n=(n+r/n)/2n,!(n===s||(n>s?n-s:s-n)<=1n););return n}static piChudnovsky(t=20n){t=BigInt(t),this._checkMaxPrecision(t);const e=t+this.config.extraPrecision,r=10n**e,s=e/14n+1n,n=426880n*this._sqrtBigInt(10005n*r,e);let i=0n;function o(t){let e=1n;for(let r=2n;r<=t;r++)e*=r;return e}function a(t,e){let r=1n;for(let s=0n;s<e;s++)r*=t;return r}for(let t=0n;t<s;t++)i+=r*(o(6n*t)*(545140134n*t+13591409n)*(t%2n==0n?1n:-1n))/(o(3n*t)*a(o(t),3n)*a(640320n,3n*t));if(0n===i)return this._makeResult(0n,t);const c=n*r/i;return this._makeResult(c,t,e)}static pi(t=20n){switch(this.config.piAlgorithm){case n.PI_CHUDNOVSKY:return this.piChudnovsky(t);case n.PI_NEWTON:return this.piNewton(t);case n.PI_LEIBNIZ:return this.piLeibniz(t)}return new this(`${Math.PI}`,t)}scale(){let t=this.value,e=this._precision;for(;e>0n&&t%10n==0n;)t/=10n,e--;return this._makeResult(t,e)}add(t){const[e,r,s]=this._rescaleToMatch(t);return this._makeResult(e+r,s)}sub(t){const[e,r,s]=this._rescaleToMatch(t);return this._makeResult(e-r,s)}mul(t){const[e,r,s,n]=this._rescaleToMatch(t,!0),i=e*r/10n**s;return this._makeResult(i,n,s)}div(t){const[e,r,s,n]=this._rescaleToMatch(t,!0),i=10n**s;if(0n===r)throw new Error("Division by zero");const o=e*i/r;return this._makeResult(o,n,s)}mod(t){const[e,r,s]=this._rescaleToMatch(t),n=e%r;return this._makeResult(n,s)}pow(t){const e=this._precision,r=10n**e;let s=BigInt(t);if(0n===s)return this._makeResult(r,e);if(0n===this.value)return this._makeResult(0n,e);if(s<0n)return this._makeResult(r,e).div(this.pow(-s));const n=this.constructor.config.extraPrecision,i=10n**(e+n);let o=this.value*10n**n,a=i;for(;s>0n;)1n&s&&(a=a*o/i),o=o*o/i,s>>=1n;return this._makeResult(a,e,e+n)}sqrt(){let t=this.value;if(t<0n)throw new Error("Cannot compute square root of negative number");const e=this.constructor.config,r=e.sqrtMaxNewtonSteps,s=e.extraPrecision,n=this._precision,i=n+s;t*=10n**s;const o=t*10n**i;let a=t/2n;0n===a&&(a=1n);let c=0n;for(let t=0;t<r&&a!==c;t++)c=a,a=(a+o/a)/2n;return this._makeResult(a,n,i)}sqrtChebyshev(){let t=this.value;if(t<0n)throw new Error("Cannot compute square root of negative number");const e=this.constructor.config,r=e.sqrtMaxChebyshevSteps,s=e.extraPrecision,n=this._precision,i=n+s,o=10n**i;t*=10n**s;const a=o*o;let c=v/2n;0n===c&&(c=1n);let u=0n;for(let e=0;e<r&&c!==u;e++){u=c;const e=c*c/o-t,r=2n*c;c=c-e*o/r-e*e/o*2n/(r*r*r/a)}return this._makeResult(c,n,i)}}e.exports={BigFloatConfig:n,BigFloat:i,bigFloat:function(t,e){return new i(t,e)}}},{"../libs/sys/JavaLibraryScriptCore":9}],15:[function(t,e,r){e.exports={...t("./BigFloat.js")}},{"./BigFloat.js":14}],16:[function(t,e,r){const s=t("../libs/IndexProxy"),n=t("./ListInterface"),i=t("../libs/TypeChecker"),o=t("./stream/StreamChecker");t("./stream/Stream");class a extends n{constructor(t,e){super(t),this._list=[],e&&this.addAll(e),s.defineInitData(this)}[Symbol.hasInstance](t){return s.hasInstance(this,t)}add(t){return this._checkValue(t),this._list.push(t),this}addAll(t){for(const e of t)this.add(e);return this}get(t){return this._list[t]}set(t,e){return this._checkValue(e),this._list[t]=e,this}remove(t){return this._list.splice(t,1)[0]}get size(){return this._list.length}clear(){this._list.length=0}equals(t){if(!(t instanceof a)||this.size!==t.size)return!1;for(let e=0;e<this.size;e++)if(this._list[e]!==t._list[e])return!1;return!0}values(){return this._list.values()}forEach(t,e){for(const r of this._list)t.call(e,r,r,this._list)}sort(t=void 0){this._list.sort(t)}*sorted(t=void 0){yield*this.toArray().sort(t)}subList(t,e){if(t<0||e>this.size||t>e)throw new RangeError(`subList(${t}, ${e}) は無効な範囲です`);return new this.constructor(this._ValueType,this._list.slice(t,e))}stream(){return o.typeToStream(this._ValueType).from(this._list,this._ValueType)}toArray(){return this._list.slice()}toString(){return`${this.constructor.name}<${i.typeNames(this._ValueType)}>(size=${this.size})`}[Symbol.iterator](){return this.values()}}const c=new s(a);e.exports={ArrayList:a,arrayList:function(t,e){return c.create(t,e)}}},{"../libs/IndexProxy":5,"../libs/TypeChecker":7,"./ListInterface":19,"./stream/Stream":26,"./stream/StreamChecker":27}],17:[function(t,e,r){const{TypeChecker:s}=t("../libs"),n=t("./MapInterface"),i=t("./stream/EntryStream");class o extends n{constructor(t,e){super(t,e)}set(t,e){return this._checkKey(t),this._checkValue(e),super.set(t,e)}put(t,e){return this.set(t,e)}setAll(t){for(const[e,r]of t.entries())this.set(e,r)}putAll(t){return this.setAll(t)}get(t){return this._checkKey(t),super.get(t)}has(t){return this._checkKey(t),super.has(t)}containsKey(t){return this.has(t)}containsValue(t){for(const e of super.values())if(e===t)return!0;return!1}delete(t){return this._checkKey(t),super.delete(t)}remove(t){return this.delete(t)}entrySet(){return this.entries()}equals(t){if(!(t instanceof Map)||this.size!==t.size)return!1;for(const[e,r]of this.entries())if(!t.has(e)||t.get(e)!==r)return!1;return!0}forEach(t,e){for(const[r,s]of this.entries())t.call(e,s,r,this)}stream(){return i.from(this.entries(),this._KeyType,this._ValueType)}toString(){return`${this.constructor.name}<${s.typeNames(this._KeyType)}, ${s.typeNames(this._ValueType)}>(size=${this.size})`}[Symbol.iterator](){return this.entries()}}e.exports=o},{"../libs":8,"./MapInterface":20,"./stream/EntryStream":24}],18:[function(t,e,r){const s=t("./SetInterface"),n=t("../libs/TypeChecker"),i=t("./stream/StreamChecker");t("./stream/Stream");class o extends s{constructor(t){super(t)}add(t){return this._checkValue(t),super.add(t)}addAll(t){for(const e of t)this.add(e);return this}has(t){return this._checkValue(t),super.has(t)}contains(t){return this.has(t)}containsAll(t){for(const e of t)if(!this.has(e))return!1;return!0}delete(t){return this._checkValue(t),super.delete(t)}remove(t){return this.delete(t)}removeAll(t){let e=!1;for(const r of t)e=this.delete(r)||e;return e}retainAll(t){const e=new Set(t);let r=!1;for(const t of this)e.has(t)||(this.delete(t),r=!0);return r}equals(t){if(!(t instanceof Set)||this.size!==t.size)return!1;for(const e of this)if(!t.has(e))return!1;return!0}forEach(t,e){for(const r of this)t.call(e,r,r,this)}stream(){return i.typeToStream(this._ValueType).from(this.values(),this._ValueType)}toArray(){return Array.from(this)}toString(){return`${this.constructor.name}<${n.typeNames(this._ValueType)}>(size=${this.size})`}[Symbol.iterator](){return this.values()}}e.exports=o},{"../libs/TypeChecker":7,"./SetInterface":21,"./stream/Stream":26,"./stream/StreamChecker":27}],19:[function(t,e,r){const s=t("../libs/sys/JavaLibraryScriptCore"),n=t("../base/Interface"),i=t("../libs/TypeChecker"),o=i.Any,a=i.NoReturn,c=[i.NotNull,i.NotUndefined];class u extends s{constructor(t){super(),this._ValueType=t||o}_checkValue(t){if(!i.matchType(t,this._ValueType))throw new TypeError(`値型が一致しません。期待: ${i.typeNames(this._ValueType)} → 実際: ${i.stringify(t)}`)}isEmpty(){return 0===this.size}}u=n.convert(u,{add:{args:[c],returns:u},get:{args:[Number],returns:o},set:{args:[Number,c],returns:u},remove:{args:[Number],returns:o},isEmpty:{returns:Boolean,abstract:!0},clear:{returns:a},toArray:{returns:Array}}),e.exports=u},{"../base/Interface":2,"../libs/TypeChecker":7,"../libs/sys/JavaLibraryScriptCore":9}],20:[function(t,e,r){const s=t("../base/Interface"),n=t("../libs/TypeChecker"),i=n.Any,o=n.NoReturn,a=[n.NotNull,n.NotUndefined];class c extends Map{constructor(t,e){super(),this._KeyType=t||i,this._ValueType=e||i}_checkKey(t){if(!n.matchType(t,this._KeyType))throw new TypeError(`キー型が一致しません。期待: ${n.typeNames(this._KeyType)} → 実際: ${n.stringify(t)}`)}_checkValue(t){if(!n.matchType(t,this._ValueType))throw new TypeError(`値型が一致しません。期待: ${n.typeNames(this._ValueType)} → 実際: ${n.stringify(t)}`)}isEmpty(){return 0===this.size}}c=s.convert(c,{set:{args:[a,a],returns:c,abstract:!0},put:{args:[a,a],returns:c},get:{args:[a],returns:i,abstract:!0},delete:{args:[a],returns:Boolean,abstract:!0},remove:{args:[a],returns:Boolean},isEmpty:{returns:Boolean,abstract:!0},clear:{returns:o},has:{args:[a],returns:Boolean,abstract:!0},containsKey:{args:[a],returns:Boolean},containsValue:{args:[a],returns:Boolean}}),e.exports=c},{"../base/Interface":2,"../libs/TypeChecker":7}],21:[function(t,e,r){const s=t("../base/Interface"),n=t("../libs/TypeChecker"),i=n.Any,o=n.NoReturn,a=[n.NotNull,n.NotUndefined];class c extends Set{constructor(t){super(),this._ValueType=t||i}_checkValue(t){if(!n.matchType(t,this._ValueType))throw new TypeError(`値型が一致しません。期待: ${n.typeNames(this._ValueType)} → 実際: ${n.stringify(t)}`)}isEmpty(){return 0===this.size}}c=s.convert(c,{add:{args:[a],returns:c},delete:{args:[a],returns:Boolean},remove:{args:[a],returns:Boolean},isEmpty:{returns:Boolean,abstract:!0},clear:{returns:o},has:{args:[a],returns:Boolean},contains:{args:[a],returns:Boolean}}),e.exports=c},{"../base/Interface":2,"../libs/TypeChecker":7}],22:[function(t,e,r){e.exports={...t("./ArrayList.js"),HashMap:t("./HashMap.js"),HashSet:t("./HashSet.js"),ListInterface:t("./ListInterface.js"),MapInterface:t("./MapInterface.js"),SetInterface:t("./SetInterface.js"),stream:t("./stream/index.js")}},{"./ArrayList.js":16,"./HashMap.js":17,"./HashSet.js":18,"./ListInterface.js":19,"./MapInterface.js":20,"./SetInterface.js":21,"./stream/index.js":30}],23:[function(t,e,r){const s=t("./StreamInterface"),n=t("./Stream");class i extends s{constructor(t){super(),this._iter=i._normalize(t),this._pipeline=[]}static from(t){return new i(t)}static _normalize(t){if("function"==typeof t[Symbol.asyncIterator])return t;if("function"==typeof t[Symbol.iterator])return async function*(){for(const e of t)yield e}();throw new TypeError("not (Async)Iterable")}_use(t){return this._pipeline.push(t),this}flattenPipeline(){const t=this._pipeline.reduceRight(((t,e)=>async function*(r){yield*e(t(r))}),(async function*(t){yield*t})),e=new this.constructor([]);return e._iter=this._iter,e._pipeline=[t],e}toFunction(){const t=this.flattenPipeline()._pipeline[0];return e=>t(e)}map(t){return this._use((async function*(e){for await(const r of e)yield await t(r)}))}filter(t){return this._use((async function*(e){for await(const r of e)await t(r)&&(yield r)}))}flatMap(t){return this._use((async function*(e){for await(const r of e){const e=await t(r);for await(const t of i._normalize(e))yield t}}))}distinct(t=t=>t){return this._use((async function*(e){const r=new Set;for await(const s of e){const e=await t(s);r.has(e)||(r.add(e),yield s)}}))}peek(t){return this._use((async function*(e){for await(const r of e)t(r),yield r}))}limit(t){return this._use((async function*(e){let r=0;for await(const s of e){if(!(r++<t))break;yield s}}))}skip(t){return this._use((async function*(e){let r=0;for await(const s of e)r++>=t&&(yield s)}))}[Symbol.asyncIterator](){let t=this._iter;for(const e of this._pipeline)t=e(t);return t[Symbol.asyncIterator]()}async forEach(t){for await(const e of this)await t(e)}async toArray(){const t=[];for await(const e of this)t.push(e);return t}async reduce(t,e){let r=e;for await(const e of this)r=await t(r,e);return r}async count(){return await this.reduce((t=>t+1),0)}async some(t){for await(const e of this)if(await t(e))return!0;return!1}async every(t){for await(const e of this)if(!await t(e))return!1;return!0}async findFirst(){for await(const t of this)return t}async find(){return await this.findFirst()}collectWith(t){return t(this)}async toLazy(){const t=[];for await(const e of this)t.push(e);return new n(t)}toString(){return`${this.constructor.name}<Promise>`}}e.exports=i},{"./Stream":26,"./StreamInterface":28}],24:[function(t,e,r){const s=t("./Stream"),n=t("./StreamChecker"),i=t("../../libs/TypeChecker"),o=i.Any;let a;e.exports=class extends s{constructor(t,e,r){super(t,r),this.mapToEntry=void 0,this._KeyType=e||o}static from(t,e,r){return new this(t,e,r)}keys(){return this._convertToX(n.typeToStream(this._KeyType)).map((([t,e])=>t))}values(){return this._convertToX(n.typeToStream(this._ValueType)).map((([t,e])=>e))}mapKeys(t){return this.map((([e,r])=>[t(e),r]))}mapValues(t){return this.map((([e,r])=>[e,t(r)]))}toHashMap(e=this._KeyType,r=this._ValueType){a||(a=t("../HashMap"));const s=new a(e,r);return this.forEach((([t,e])=>s.set(t,e))),s}toString(){return`${this.constructor.name}<${i.typeNames(this._KeyType)}, ${i.typeNames(this._ValueType)}>`}}},{"../../libs/TypeChecker":7,"../HashMap":17,"./Stream":26,"./StreamChecker":27}],25:[function(t,e,r){const s=t("./Stream");e.exports=class extends s{constructor(t){super(t,Number),this.mapToNumber=void 0}sum(){let t=0;for(const e of this)t+=e;return t}average(){let t=0,e=0;for(const r of this)t+=r,e++;return 0===e?NaN:t/e}min(){let t=1/0;for(const e of this)e<t&&(t=e);return t===1/0?null:t}max(){let t=-1/0;for(const e of this)e>t&&(t=e);return t===-1/0?null:t}}},{"./Stream":26}],26:[function(t,e,r){const s=t("./StreamInterface"),n=t("../../libs/TypeChecker"),i=n.Any;let o,a,c,u,h;class l extends s{constructor(e,r){super(),this._iter=e[Symbol.iterator](),this._pipeline=[],this._ValueType=r||i,o||(o=t("./NumberStream"),a=t("./StringStream"),c=t("./EntryStream"),u=t("./AsyncStream"),h=t("../HashSet"))}static from(t,e){return new this(t,e)}_use(t){return this._pipeline.push(t),this}_convertToX(t,e,...r){const s=new t([],...r);return s._iter=this._iter,s._pipeline=[...this._pipeline],e&&s._pipeline.push(e),s}flattenPipeline(){const t=this._pipeline.reduceRight(((t,e)=>function*(r){yield*e(t(r))}),(t=>t)),e=new this.constructor([]);return e._iter=this._iter,e._pipeline=[t],e}toFunction(){const t=this.flattenPipeline()._pipeline[0];return e=>t(e)}map(t){return this._use((function*(e){for(const r of e)yield t(r)}))}filter(t){return this._use((function*(e){for(const r of e)t(r)&&(yield r)}))}flatMap(t){return this._use((function*(e){for(const r of e){const e=t(r);yield*e instanceof s?e:e[Symbol.iterator]()}}))}distinct(t=JSON.stringify.bind(JSON)){return this._use((function*(e){const r=new Set;for(const s of e){const e=t(s);r.has(e)||(r.add(e),yield s)}}))}sorted(t=(t,e)=>t>e?1:t<e?-1:0){return this._use((function*(e){const r=[...e].sort(t);yield*r}))}peek(t){return this._use((function*(e){for(const r of e)t(r),yield r}))}limit(t){return this._use((function*(e){let r=0;for(const s of e){if(r++>=t)break;yield s}}))}skip(t){return this._use((function*(e){let r=0;for(const s of e)r++<t||(yield s)}))}chunk(t){return this._use((function*(e){let r=[];for(const s of e)r.push(s),r.length===t&&(yield r,r=[]);r.length&&(yield r)}))}windowed(t,e=t){return this._use((function*(r){const s=[];for(const n of r)s.push(n),s.length===t&&(yield s.slice(),s.splice(0,e))}))}[Symbol.iterator](){return this._pipeline.reduce(((t,e)=>e(t)),this._iter)}[Symbol.asyncIterator](){let t=this._pipeline.reduce(((t,e)=>e(t)),this._iter);return{next:async()=>Promise.resolve(t.next())}}forEach(t){for(const e of this)t(e)}toArray(){return Array.from(this)}reduce(t,e){let r=e;for(const e of this)r=t(r,e);return r}count(){let t=0;for(const e of this)t++;return t}some(t){for(const e of this)if(t(e))return!0;return!1}every(t){for(const e of this)if(!t(e))return!1;return!0}findFirst(){for(const t of this)return t}findAny(){return this.findFirst()}collectWith(t){return t(this)}mapToNumber(t){return this._convertToX(o,(function*(e){for(const r of e){const e=t(r);if("number"!=typeof e)throw new TypeError("mapToNumber() must return number. Got "+typeof e);yield e}}))}mapToString(t){return this._convertToX(a,(function*(e){for(const r of e){const e=t(r);if("string"!=typeof e)throw new TypeError("mapToString() must return string. Got "+typeof e);yield e}}))}mapToEntry(t){return this._convertToX(c,(function*(e){for(const r of e){const e=t(r);if(!Array.isArray(e)||2!==e.length)throw new TypeError(`mapToEntry() must return [key, value] pair. Got: ${e}`);yield e}}),i,i)}mapToAsync(t){const e=this.flattenPipeline(),r=e._pipeline[0](e._iter),s=async function*(){for(const e of r)yield await t(e)}();return new u(s)}toHashSet(t=this._ValueType){const e=new h(t);for(const t of this)e.add(t);return e}toString(){return`${this.constructor.name}<${n.typeNames(this._ValueType)}>`}}e.exports=l},{"../../libs/TypeChecker":7,"../HashSet":18,"./AsyncStream":23,"./EntryStream":24,"./NumberStream":25,"./StreamInterface":28,"./StringStream":29}],27:[function(t,e,r){const s=t("../../libs/sys/JavaLibraryScriptCore"),n=t("../../libs/TypeChecker");let i,o,a,c,u;function h(){i||(i=t("./Stream"),o=t("./NumberStream"),a=t("./StringStream"),c=t("./EntryStream"),u=t("./AsyncStream"))}t("./StreamInterface"),e.exports=class extends s{static typeToStream(t){return h(),null==t?i:t===String?a:t===Number?o:t===Map?c:t===Promise?u:i}static streamToType(t){return h(),t instanceof a?String:t instanceof o?Number:t instanceof c?Map:t instanceof u?Promise:t instanceof i?n.Any:null}}},{"../../libs/TypeChecker":7,"../../libs/sys/JavaLibraryScriptCore":9,"./AsyncStream":23,"./EntryStream":24,"./NumberStream":25,"./Stream":26,"./StreamInterface":28,"./StringStream":29}],28:[function(t,e,r){const s=t("../../libs/sys/JavaLibraryScriptCore"),n=t("../../base/Interface");class i extends s{constructor(){super()}}i=n.convert(i,{map:{args:[Function],returns:i},filter:{args:[Function],returns:i},flatMap:{args:[Function],returns:i},forEach:{args:[[Function,Promise]],returns:[void 0,Promise]}}),e.exports=i},{"../../base/Interface":2,"../../libs/sys/JavaLibraryScriptCore":9}],29:[function(t,e,r){const s=t("./Stream");e.exports=class extends s{constructor(t){super(t,String),this.mapToString=void 0}join(t=" "){return Array.from(this).join(t)}concatAll(){return this.join("")}longest(){let t="";for(const e of this)e.length>t.length&&(t=e);return t||null}shortest(){let t=null;for(const e of this)(null===t||e.length<t.length)&&(t=e);return t||null}}},{"./Stream":26}],30:[function(t,e,r){e.exports={AsyncStream:t("./AsyncStream.js"),EntryStream:t("./EntryStream.js"),NumberStream:t("./NumberStream.js"),Stream:t("./Stream.js"),StreamChecker:t("./StreamChecker.js"),StreamInterface:t("./StreamInterface.js"),StringStream:t("./StringStream.js")}},{"./AsyncStream.js":23,"./EntryStream.js":24,"./NumberStream.js":25,"./Stream.js":26,"./StreamChecker.js":27,"./StreamInterface.js":28,"./StringStream.js":29}]},{},[13]);
//# sourceMappingURL=JavaLibraryScript.min.js.map