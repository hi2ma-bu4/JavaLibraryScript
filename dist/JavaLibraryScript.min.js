!function e(t,r,n){function i(o,a){if(!r[o]){if(!t[o]){var c="function"==typeof require&&require;if(!a&&c)return c(o,!0);if(s)return s(o,!0);var u=new Error("Cannot find module '"+o+"'");throw u.code="MODULE_NOT_FOUND",u}var f=r[o]={exports:{}};t[o][0].call(f.exports,(function(e){return i(t[o][1][e]||e)}),f,f.exports,e,t,r,n)}return r[o].exports}for(var s="function"==typeof require&&require,o=0;o<n.length;o++)i(n[o]);return i}({1:[function(e,t,r){class n{constructor(e,t,r=e,n=null,i={}){this.name=e,this.ordinal=t,this.value=r,this.owner=n;for(const[e,t]of Object.entries(i))"function"==typeof t&&(this[e]=t.bind(this));Object.freeze(this)}toString(){return this.name}toJSON(){return this.name}compareTo(e){return this.ordinal-e.ordinal}equals(e){return e instanceof n&&this.name===e.name&&this.ordinal===e.ordinal&&this.value===e.value}hashCode(){return this.name.split("").reduce(((e,t)=>e+t.charCodeAt(0)),0)+31*this.ordinal}}class i{constructor(e,t={}){let r;if(this._items=[],this._methods=t.methods||{},Array.isArray(e))r=e.map((e=>Array.isArray(e)?e:[e,e]));else{if("object"!=typeof e||null===e)throw new TypeError("DynamicEnum: 配列か連想配列で定義してください");r=Object.entries(e)}r.forEach((([e,t],r)=>{const i=new n(e,r,t,this,this._methods);Object.defineProperty(this,e,{value:i,writable:!1,configurable:!1,enumerable:!0}),this._items.push(i)})),Object.freeze(this._items)}values(){return this._items.slice()}valueOf(e){return this[e]}fromName=valueOf;fromValue(e){return this._items.find((t=>t.value===e))}fromOrdinal(e){return this._items.find((t=>t.ordinal===e))}has(e){return"object"==typeof this[e]&&this[e]instanceof n}entries(){return this._items.map((e=>[e.name,e]))}keys(){return this._items.map((e=>e.name))}toMap(){const e={};for(const t of this._items)e[t.name]=t.value;return e}toJSON(){return this._items.map((e=>e.toJSON()))}*[Symbol.iterator](){yield*this._items}*enumerate(){for(let e=0;e<this._items.length;e++)yield[e,this._items[e]]}}t.exports={_EnumItem:n,_EnumCore:i,Enum:function(e,t={}){const r=new i(e,t);return new Proxy(r,{get(e,t,r){if("string"==typeof t&&/^[0-9]+$/.test(t)){const r=Number(t);return e._items[r]}return Reflect.get(e,t,r)},enumerate:e=>Object.keys(e._items).map((e=>e.toString())),has(e,t){if("string"==typeof t&&/^[0-9]+$/.test(t)){const r=Number(t);return r>=0&&r<e._items.length}return t in e},ownKeys:e=>[...Reflect.ownKeys(e),...e._items.map(((e,t)=>t.toString()))],getOwnPropertyDescriptor:(e,t)=>"string"==typeof t&&/^[0-9]+$/.test(t)?t in e._items?{value:e._items[Number(t)],writable:!1,configurable:!1,enumerable:!0}:void 0:Object.getOwnPropertyDescriptor(e,t),set(e,t,r){throw new TypeError(`Enumは変更できません: ${String(t)} = ${r}`)},defineProperty(e,t,r){throw new TypeError(`Enumにプロパティを追加/変更できません: ${String(t)}`)},deleteProperty(e,t){throw new TypeError(`Enumのプロパティを削除できません: ${String(t)}`)}})}}},{}],2:[function(e,t,r){t.exports={Enum:e("./Enum.js")}},{"./Enum.js":1}],3:[function(e,t,r){t.exports={main:e("./main.js"),base:e("./base/index.js"),libs:e("./libs/index.js"),util:e("./util/index.js")}},{"./base/index.js":2,"./libs/index.js":5,"./main.js":6,"./util/index.js":8}],4:[function(e,t,r){const{_EnumCore:n,_EnumItem:i}=e("../base/Enum.js");class s{static matchType(e,t){return Array.isArray(t)?t.some((t=>this.checkType(e,t))):this.checkType(e,t)}static checkType(e,t){return null===t?null===e:void 0===t?void 0===e:t===String||t===Number||t===Boolean||t===Symbol||t===Function||t===BigInt?typeof e===t.name.toLowerCase():t===Object?"object"==typeof e&&null!==e&&!Array.isArray(e):t===Array?Array.isArray(e):t instanceof n?t.has(e?.name):t===i?e instanceof i:"function"==typeof t&&e instanceof t}static typeNames(e){return Array.isArray(e)?e.map((e=>e?.name||s.stringify(e))).join(" | "):e?.name||s.stringify(e)}static stringify(e){if(null==e)return String(e);if("object"==typeof e){if("[object Object]"!==e?.toString())return String(e);try{const t=JSON.stringify(e,((e,t)=>{if(t&&"object"==typeof t){const e=Object.keys(t).length;if(e>5)return`Object with ${e} properties`}return t}),0);return void 0===t?"Object is too large to display or contains circular references":t.length>1e3?"Object is too large to display":t}catch(e){return`[オブジェクト表示エラー: ${e.message}]`}}return String(e)}}t.exports=s},{"../base/Enum.js":1}],5:[function(e,t,r){t.exports={TypeChecker:e("./TypeChecker.js")}},{"./TypeChecker.js":4}],6:[function(e,t,r){const n=e("./index.js");"undefined"!=typeof window&&(window.JavaLibraryScript=n),t.exports=n},{"./index.js":3}],7:[function(e,t,r){const n=e("../libs/TypeChecker.js");class i{static _isDebugMode=!1;static methodTypes={};constructor(){if(new.target===i)throw new Error("Interfaceは直接インスタンス化できません。継承して使ってください。");if(!i._isDebugMode)return;const e=/^\s*class\s+/,t=this.constructor,r=t.methodTypes||{};for(const i in r){const s=r[i];if("function"!=typeof this[i])throw new Error(`"${t.name}" はメソッド "${i}" を実装する必要があります`);const o=this[i].bind(this);this[i]=(...r)=>{const a=s.args||[];for(let e=0;e<a.length;e++)if(!n.matchType(r[e],a[e]))throw new TypeError(`"${t.name}.${i}" 第${e+1}引数: ${n.typeNames(a[e])} を期待 → 実際: ${n.stringify(r[e])}`);const c=o(...r),u=s.returns,f="function"!=typeof u||e.test(u.toString())?u:u(r),m=e=>{if(!n.matchType(e,f))throw new TypeError(`"${t.name}.${i}" の戻り値: ${n.typeNames(f)} を期待 → 実際: ${n.stringify(e)}`);return e};return c instanceof Promise?c.then(m):m(c)}}}}t.exports=i},{"../libs/TypeChecker.js":4}],8:[function(e,t,r){t.exports={Interface:e("./Interface.js")}},{"./Interface.js":7}]},{},[6]);
//# sourceMappingURL=JavaLibraryScript.min.js.map