{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/base/Enum.js",
    "src/base/index.js",
    "src/index.js",
    "src/libs/TypeChecker.js",
    "src/libs/index.js",
    "src/main.js",
    "src/util/Interface.js",
    "src/util/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5RA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "/**\r\n * 単一のEnum要素を表すクラス\r\n */\r\nclass _EnumItem {\r\n\t/**\r\n\t * @param {string} name - Enumのキー名\r\n\t * @param {number} ordinal - 順序番号（自動インクリメント）\r\n\t * @param {any} value - 任意の値（name, 数値, オブジェクトなど）\r\n\t * @param {_EnumCore} [owner] - Enumのインスタンス\r\n\t * @param {{[methodName: string]: (...args: any[]) => any}} [methods] - Enumのメソッド\r\n\t */\r\n\tconstructor(name, ordinal, value = name, owner = null, methods = {}) {\r\n\t\tthis.name = name;\r\n\t\tthis.ordinal = ordinal;\r\n\t\tthis.value = value;\r\n\r\n\t\tthis.owner = owner;\r\n\r\n\t\tfor (const [key, fn] of Object.entries(methods)) {\r\n\t\t\tif (typeof fn === \"function\") {\r\n\t\t\t\tthis[key] = fn.bind(this);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\t/**\r\n\t * 名前を返す\r\n\t * @returns {string}\r\n\t */\r\n\ttoString() {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\t/**\r\n\t * JSON化\r\n\t * @returns {string}\r\n\t */\r\n\ttoJSON() {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\t/**\r\n\t * ordinalでの比較\r\n\t * @param {_EnumItem} other\r\n\t * @returns {number}\r\n\t */\r\n\tcompareTo(other) {\r\n\t\treturn this.ordinal - other.ordinal;\r\n\t}\r\n\r\n\t/**\r\n\t * 同一EnumItemかチェック\r\n\t * @param {_EnumItem} other\r\n\t * @returns {boolean}\r\n\t */\r\n\tequals(other) {\r\n\t\treturn other instanceof _EnumItem && this.name === other.name && this.ordinal === other.ordinal && this.value === other.value;\r\n\t}\r\n\r\n\t/**\r\n\t * ハッシュコード生成（簡易）\r\n\t * @returns {number}\r\n\t */\r\n\thashCode() {\r\n\t\treturn this.name.split(\"\").reduce((h, c) => h + c.charCodeAt(0), 0) + this.ordinal * 31;\r\n\t}\r\n}\r\n\r\n/**\r\n * Enum を生成するクラス\r\n */\r\nclass _EnumCore {\r\n\t/**\r\n\t * @param {Array<string | [string, any]> | Record<string, any>} defs - 定義\r\n\t * @param {{[methodName: string]: (...args: any[]) => any}} [options.methods] - Enumのメソッド\r\n\t */\r\n\tconstructor(defs, options = {}) {\r\n\t\t/** @type {_EnumItem[]} */\r\n\t\tthis._items = [];\r\n\t\tthis._methods = options.methods || {};\r\n\r\n\t\tlet entries;\r\n\r\n\t\tif (Array.isArray(defs)) {\r\n\t\t\tentries = defs.map((def) => (Array.isArray(def) ? def : [def, def]));\r\n\t\t} else if (typeof defs === \"object\" && defs !== null) {\r\n\t\t\tentries = Object.entries(defs);\r\n\t\t} else {\r\n\t\t\tthrow new TypeError(\"DynamicEnum: 配列か連想配列で定義してください\");\r\n\t\t}\r\n\r\n\t\tentries.forEach(([name, value], index) => {\r\n\t\t\tconst item = new _EnumItem(name, index, value, this, this._methods);\r\n\t\t\tObject.defineProperty(this, name, {\r\n\t\t\t\tvalue: item,\r\n\t\t\t\twritable: false,\r\n\t\t\t\tconfigurable: false,\r\n\t\t\t\tenumerable: true,\r\n\t\t\t});\r\n\t\t\tthis._items.push(item);\r\n\t\t});\r\n\r\n\t\tObject.freeze(this._items);\r\n\t}\r\n\r\n\t/**\r\n\t * Enumの全要素を配列で取得\r\n\t * @returns {_EnumItem[]}\r\n\t */\r\n\tvalues() {\r\n\t\treturn this._items.slice();\r\n\t}\r\n\r\n\t/**\r\n\t * 名前からEnumItemを取得\r\n\t * @param {string} name\r\n\t * @returns {_EnumItem | undefined}\r\n\t */\r\n\tvalueOf(name) {\r\n\t\treturn this[name];\r\n\t}\r\n\t/**\r\n\t * 名前からEnumItemを取得\r\n\t * @param {string} name\r\n\t * @returns {_EnumItem | undefined}\r\n\t */\r\n\tfromName = valueOf;\r\n\r\n\t/**\r\n\t * 値からEnumItemを取得\r\n\t * @param {any} value\r\n\t * @returns {_EnumItem | undefined}\r\n\t */\r\n\tfromValue(value) {\r\n\t\treturn this._items.find((e) => e.value === value);\r\n\t}\r\n\r\n\t/**\r\n\t * ordinalからEnumItemを取得\r\n\t * @param {number} ordinal\r\n\t * @returns {_EnumItem | undefined}\r\n\t */\r\n\tfromOrdinal(ordinal) {\r\n\t\treturn this._items.find((e) => e.ordinal === ordinal);\r\n\t}\r\n\r\n\t/**\r\n\t * Enumにそのnameが存在するか\r\n\t * @param {string} name\r\n\t * @returns {boolean}\r\n\t */\r\n\thas(name) {\r\n\t\treturn typeof this[name] === \"object\" && this[name] instanceof _EnumItem;\r\n\t}\r\n\r\n\t/**\r\n\t * name → _EnumItem の [name, item] 配列を返す\r\n\t * @returns {[string, _EnumItem][]}\r\n\t */\r\n\tentries() {\r\n\t\treturn this._items.map((e) => [e.name, e]);\r\n\t}\r\n\r\n\t/**\r\n\t * Enumの全nameを返す\r\n\t * @returns {string[]}\r\n\t */\r\n\tkeys() {\r\n\t\treturn this._items.map((e) => e.name);\r\n\t}\r\n\r\n\t/**\r\n\t * name → value のマップを返す\r\n\t * @returns {Record<string, any>}\r\n\t */\r\n\ttoMap() {\r\n\t\tconst map = {};\r\n\t\tfor (const e of this._items) {\r\n\t\t\tmap[e.name] = e.value;\r\n\t\t}\r\n\t\treturn map;\r\n\t}\r\n\r\n\t/**\r\n\t * JSONシリアライズ用のtoJSONメソッド\r\n\t * @returns {Array<{name: string, ordinal: number, value: any}>} 列挙子の配列\r\n\t */\r\n\ttoJSON() {\r\n\t\treturn this._items.map((item) => item.toJSON());\r\n\t}\r\n\r\n\t/**\r\n\t * for...of に対応\r\n\t */\r\n\t*[Symbol.iterator]() {\r\n\t\tyield* this._items;\r\n\t}\r\n\r\n\t/**\r\n\t * インデックス付きで列挙子を返すジェネレータ\r\n\t * @returns {Generator<[number, _EnumItem]>} インデックスと列挙子のペア\r\n\t */\r\n\t*enumerate() {\r\n\t\tfor (let i = 0; i < this._items.length; i++) {\r\n\t\t\tyield [i, this._items[i]];\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * DynamicEnum生成関数（インデックスアクセスに対応したProxy付き）\r\n * @param {Array<string | [string, any]> | Record<string, any>} defs\r\n * @param {{[methodName: string]: (...args: any[]) => any}} [options.methods] - Enumのメソッド\r\n * @returns {_EnumCore & Proxy}\r\n */\r\nfunction Enum(defs, options = {}) {\r\n\tconst core = new _EnumCore(defs, options);\r\n\treturn new Proxy(core, {\r\n\t\tget(target, prop, receiver) {\r\n\t\t\tif (typeof prop === \"string\" && /^[0-9]+$/.test(prop)) {\r\n\t\t\t\tconst index = Number(prop);\r\n\t\t\t\treturn target._items[index];\r\n\t\t\t}\r\n\t\t\treturn Reflect.get(target, prop, receiver);\r\n\t\t},\r\n\r\n\t\tenumerate(target) {\r\n\t\t\t// 数字のインデックスを除外\r\n\t\t\treturn Object.keys(target._items).map((i) => i.toString());\r\n\t\t},\r\n\r\n\t\thas(target, prop) {\r\n\t\t\tif (typeof prop === \"string\" && /^[0-9]+$/.test(prop)) {\r\n\t\t\t\tconst index = Number(prop);\r\n\t\t\t\treturn index >= 0 && index < target._items.length;\r\n\t\t\t}\r\n\t\t\treturn prop in target;\r\n\t\t},\r\n\r\n\t\townKeys(target) {\r\n\t\t\tconst keys = Reflect.ownKeys(target);\r\n\t\t\tconst indexes = target._items.map((_, i) => i.toString());\r\n\t\t\treturn [...keys, ...indexes];\r\n\t\t},\r\n\r\n\t\tgetOwnPropertyDescriptor(target, prop) {\r\n\t\t\tif (typeof prop === \"string\" && /^[0-9]+$/.test(prop)) {\r\n\t\t\t\t// プロパティがターゲットに存在するか確認\r\n\t\t\t\tif (prop in target._items) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tvalue: target._items[Number(prop)],\r\n\t\t\t\t\t\twritable: false,\r\n\t\t\t\t\t\tconfigurable: false,\r\n\t\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\t};\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// プロパティが存在しない場合はエラーを避ける\r\n\t\t\t\t\treturn undefined; // これでエラーを避ける\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Object.getOwnPropertyDescriptor(target, prop);\r\n\t\t},\r\n\r\n\t\tset(target, prop, value) {\r\n\t\t\tthrow new TypeError(`Enumは変更できません: ${String(prop)} = ${value}`);\r\n\t\t},\r\n\r\n\t\tdefineProperty(target, prop, descriptor) {\r\n\t\t\tthrow new TypeError(`Enumにプロパティを追加/変更できません: ${String(prop)}`);\r\n\t\t},\r\n\r\n\t\tdeleteProperty(target, prop) {\r\n\t\t\tthrow new TypeError(`Enumのプロパティを削除できません: ${String(prop)}`);\r\n\t\t},\r\n\t});\r\n}\r\n\r\nmodule.exports = {\r\n\t_EnumItem,\r\n\t_EnumCore,\r\n\tEnum,\r\n};\r\n",
    "module.exports = {\n  ...require(\"./Enum.js\")\n};\n",
    "module.exports = {\n  base: require(\"./base\"),\n  libs: require(\"./libs\"),\n  util: require(\"./util\")\n};\n",
    "const { _EnumCore, _EnumItem } = require(\"../base/Enum.js\");\r\n\r\nclass TypeChecker {\r\n\tstatic matchType(value, expected) {\r\n\t\tif (Array.isArray(expected)) return expected.some((e) => this.checkType(value, e));\r\n\t\treturn this.checkType(value, expected);\r\n\t}\r\n\r\n\tstatic checkType(value, expected) {\r\n\t\tif (expected === null) return value === null;\r\n\t\tif (expected === undefined) return value === undefined;\r\n\t\tif (expected === String || expected === Number || expected === Boolean || expected === Symbol || expected === Function || expected === BigInt) return typeof value === expected.name.toLowerCase();\r\n\t\tif (expected === Object) return typeof value === \"object\" && value !== null && !Array.isArray(value);\r\n\t\tif (expected === Array) return Array.isArray(value);\r\n\t\t// ----- Enum対応\r\n\t\tif (expected instanceof _EnumCore) {\r\n\t\t\t// Enumの場合\r\n\t\t\treturn expected.has(value?.name);\r\n\t\t}\r\n\t\tif (expected === _EnumItem) return value instanceof _EnumItem;\r\n\t\t// -----\r\n\t\tif (typeof expected === \"function\") return value instanceof expected;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tstatic typeNames(expected) {\r\n\t\tif (Array.isArray(expected)) return expected.map((t) => t?.name || TypeChecker.stringify(t)).join(\" | \");\r\n\t\treturn expected?.name || TypeChecker.stringify(expected);\r\n\t}\r\n\r\n\tstatic stringify(value) {\r\n\t\tif (value === null || value === undefined) {\r\n\t\t\treturn String(value);\r\n\t\t}\r\n\t\tif (typeof value === \"object\") {\r\n\t\t\tif (value?.toString() !== \"[object Object]\") {\r\n\t\t\t\treturn String(value);\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tconst jsonString = JSON.stringify(\r\n\t\t\t\t\tvalue,\r\n\t\t\t\t\t(key, val) => {\r\n\t\t\t\t\t\tif (val && typeof val === \"object\") {\r\n\t\t\t\t\t\t\tconst size = Object.keys(val).length;\r\n\t\t\t\t\t\t\t// オブジェクトが大きすぎる場合は省略表示\r\n\t\t\t\t\t\t\tif (size > 5) {\r\n\t\t\t\t\t\t\t\treturn `Object with ${size} properties`;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn val;\r\n\t\t\t\t\t},\r\n\t\t\t\t\t0\r\n\t\t\t\t);\r\n\t\t\t\t// JSON.stringifyエラー時にfallback\r\n\t\t\t\tif (jsonString === undefined) {\r\n\t\t\t\t\treturn \"Object is too large to display or contains circular references\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn jsonString.length > 1000 ? \"Object is too large to display\" : jsonString; // 文字数が多すぎる場合は省略\r\n\t\t\t} catch (e) {\r\n\t\t\t\treturn `[オブジェクト表示エラー: ${e.message}]`; // サークル参照等のエラー防止\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn String(value); // それ以外の型はそのまま文字列に変換\r\n\t}\r\n}\r\n\r\nmodule.exports = TypeChecker;\r\n",
    "module.exports = {\n  TypeChecker: require(\"./TypeChecker.js\")\n};\n",
    "const JavaLibraryScript = require(\"./index.js\");\n\nif (typeof window !== \"undefined\") {\n\twindow.JavaLibraryScript = JavaLibraryScript;\n}\n\nmodule.exports = JavaLibraryScript;\n",
    "const TypeChecker = require(\"../libs/TypeChecker.js\");\r\n\r\nclass Interface {\r\n\tstatic _isDebugMode = false;\r\n\r\n\tstatic methodTypes = {};\r\n\r\n\tconstructor() {\r\n\t\tif (new.target === Interface) {\r\n\t\t\tthrow new Error(\"Interfaceは直接インスタンス化できません。継承して使ってください。\");\r\n\t\t}\r\n\r\n\t\tif (!Interface._isDebugMode) return;\r\n\r\n\t\tconst CLASS_REG = /^\\s*class\\s+/;\r\n\r\n\t\tconst cls = this.constructor;\r\n\t\tconst typeDefs = cls.methodTypes || {};\r\n\r\n\t\tfor (const method in typeDefs) {\r\n\t\t\tconst def = typeDefs[method];\r\n\t\t\tif (typeof this[method] !== \"function\") {\r\n\t\t\t\tthrow new Error(`\"${cls.name}\" はメソッド \"${method}\" を実装する必要があります`);\r\n\t\t\t}\r\n\r\n\t\t\tconst originalMethod = this[method].bind(this);\r\n\r\n\t\t\tthis[method] = (...args) => {\r\n\t\t\t\t// 引数チェック\r\n\t\t\t\tconst expectedArgs = def.args || [];\r\n\t\t\t\tfor (let i = 0; i < expectedArgs.length; i++) {\r\n\t\t\t\t\tif (!TypeChecker.matchType(args[i], expectedArgs[i])) {\r\n\t\t\t\t\t\tthrow new TypeError(`\"${cls.name}.${method}\" 第${i + 1}引数: ${TypeChecker.typeNames(expectedArgs[i])} を期待 → 実際: ${TypeChecker.stringify(args[i])}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst result = originalMethod(...args);\r\n\r\n\t\t\t\t// 戻り値型を動的に取得\r\n\t\t\t\tconst ret = def.returns;\r\n\t\t\t\tconst expectedReturn = typeof ret === \"function\" && !CLASS_REG.test(ret.toString()) ? ret(args) : ret;\r\n\r\n\t\t\t\tconst validate = (val) => {\r\n\t\t\t\t\tif (!TypeChecker.matchType(val, expectedReturn)) {\r\n\t\t\t\t\t\tthrow new TypeError(`\"${cls.name}.${method}\" の戻り値: ${TypeChecker.typeNames(expectedReturn)} を期待 → 実際: ${TypeChecker.stringify(val)}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn val;\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (result instanceof Promise) {\r\n\t\t\t\t\treturn result.then(validate);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn validate(result);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = Interface;\r\n",
    "module.exports = {\n  Interface: require(\"./Interface.js\")\n};\n"
  ]
}