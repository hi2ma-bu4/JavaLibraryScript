{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/base/Enum.js",
    "src/base/Interface.js",
    "src/base/index.js",
    "src/index.js",
    "src/libs/TypeChecker.js",
    "src/libs/index.js",
    "src/libs/sys/JavaLibraryScriptCore.js",
    "src/libs/sys/index.js",
    "src/main.js",
    "src/util/HashMap.js",
    "src/util/HashSet.js",
    "src/util/MapInterface.js",
    "src/util/SetInterface.js",
    "src/util/index.js",
    "src/util/stream/AsyncStream.js",
    "src/util/stream/EntryStream.js",
    "src/util/stream/NumberStream.js",
    "src/util/stream/Stream.js",
    "src/util/stream/StreamChecker.js",
    "src/util/stream/StreamInterface.js",
    "src/util/stream/StringStream.js",
    "src/util/stream/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1RA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7PA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "const JavaLibraryScriptCore = require(\"../libs/sys/JavaLibraryScriptCore.js\");\r\n\r\n/**\r\n * 単一のEnum要素を表すクラス\r\n * @extends {JavaLibraryScriptCore}\r\n * @class\r\n */\r\nclass _EnumItem extends JavaLibraryScriptCore {\r\n\t/**\r\n\t * @param {string} name - Enumのキー名\r\n\t * @param {number} ordinal - 順序番号（自動インクリメント）\r\n\t * @param {any} value - 任意の値（name, 数値, オブジェクトなど）\r\n\t * @param {_EnumCore} [owner] - Enumのインスタンス\r\n\t * @param {{[methodName: string]: (...args: any[]) => any}} [methods] - Enumのメソッド\r\n\t */\r\n\tconstructor(name, ordinal, value = name, owner = null, methods = {}) {\r\n\t\tsuper();\r\n\t\tthis.name = name;\r\n\t\tthis.ordinal = ordinal;\r\n\t\tthis.value = value;\r\n\r\n\t\tthis.owner = owner;\r\n\r\n\t\tfor (const [key, fn] of Object.entries(methods)) {\r\n\t\t\tif (typeof fn === \"function\") {\r\n\t\t\t\tthis[key] = fn.bind(this);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\t/**\r\n\t * 名前を返す\r\n\t * @returns {string}\r\n\t */\r\n\ttoString() {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\t/**\r\n\t * JSON化\r\n\t * @returns {string}\r\n\t */\r\n\ttoJSON() {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\t/**\r\n\t * ordinalでの比較\r\n\t * @param {this} other\r\n\t * @returns {number}\r\n\t */\r\n\tcompareTo(other) {\r\n\t\treturn this.ordinal - other.ordinal;\r\n\t}\r\n\r\n\t/**\r\n\t * 同一EnumItemかチェック\r\n\t * @param {this} other\r\n\t * @returns {boolean}\r\n\t */\r\n\tequals(other) {\r\n\t\treturn other instanceof _EnumItem && this.name === other.name && this.ordinal === other.ordinal && this.value === other.value;\r\n\t}\r\n\r\n\t/**\r\n\t * ハッシュコード生成（簡易）\r\n\t * @returns {number}\r\n\t */\r\n\thashCode() {\r\n\t\treturn this.name.split(\"\").reduce((h, c) => h + c.charCodeAt(0), 0) + this.ordinal * 31;\r\n\t}\r\n}\r\n\r\n/**\r\n * Enum を生成するクラス\r\n * @extends {JavaLibraryScriptCore}\r\n * @class\r\n */\r\nclass _EnumCore extends JavaLibraryScriptCore {\r\n\t/**\r\n\t * @param {Array<string | [string, any]> | Record<string, any>} defs - 定義\r\n\t * @param {{[methodName: string]: (...args: any[]) => any}} [options.methods] - Enumのメソッド\r\n\t */\r\n\tconstructor(defs, options = {}) {\r\n\t\tsuper();\r\n\t\t/** @type {_EnumItem[]} */\r\n\t\tthis._items = [];\r\n\t\tthis._methods = options.methods || {};\r\n\r\n\t\tlet entries;\r\n\r\n\t\tif (Array.isArray(defs)) {\r\n\t\t\tentries = defs.map((def) => (Array.isArray(def) ? def : [def, def]));\r\n\t\t} else if (typeof defs === \"object\" && defs !== null) {\r\n\t\t\tentries = Object.entries(defs);\r\n\t\t} else {\r\n\t\t\tthrow new TypeError(\"Enum: 配列か連想配列で定義してください\");\r\n\t\t}\r\n\r\n\t\tentries.forEach(([name, value], index) => {\r\n\t\t\tconst item = new _EnumItem(name, index, value, this, this._methods);\r\n\t\t\tObject.defineProperty(this, name, {\r\n\t\t\t\tvalue: item,\r\n\t\t\t\twritable: false,\r\n\t\t\t\tconfigurable: false,\r\n\t\t\t\tenumerable: true,\r\n\t\t\t});\r\n\t\t\tthis._items.push(item);\r\n\t\t});\r\n\r\n\t\tObject.freeze(this._items);\r\n\t}\r\n\r\n\t/**\r\n\t * Enumの全要素を配列で取得\r\n\t * @returns {_EnumItem[]}\r\n\t */\r\n\tvalues() {\r\n\t\treturn this._items.slice();\r\n\t}\r\n\r\n\t/**\r\n\t * 名前からEnumItemを取得\r\n\t * @param {string} name\r\n\t * @returns {_EnumItem | undefined}\r\n\t */\r\n\tvalueOf(name) {\r\n\t\treturn this[name];\r\n\t}\r\n\t/**\r\n\t * 名前からEnumItemを取得\r\n\t * @param {string} name\r\n\t * @returns {_EnumItem | undefined}\r\n\t */\r\n\tfromName = valueOf;\r\n\r\n\t/**\r\n\t * 値からEnumItemを取得\r\n\t * @param {any} value\r\n\t * @returns {_EnumItem | undefined}\r\n\t */\r\n\tfromValue(value) {\r\n\t\treturn this._items.find((e) => e.value === value);\r\n\t}\r\n\r\n\t/**\r\n\t * ordinalからEnumItemを取得\r\n\t * @param {number} ordinal\r\n\t * @returns {_EnumItem | undefined}\r\n\t */\r\n\tfromOrdinal(ordinal) {\r\n\t\treturn this._items.find((e) => e.ordinal === ordinal);\r\n\t}\r\n\r\n\t/**\r\n\t * Enumにそのnameが存在するか\r\n\t * @param {string} name\r\n\t * @returns {boolean}\r\n\t */\r\n\thas(name) {\r\n\t\treturn typeof this[name] === \"object\" && this[name] instanceof _EnumItem;\r\n\t}\r\n\r\n\t/**\r\n\t * name → _EnumItem の [name, item] 配列を返す\r\n\t * @returns {[string, _EnumItem][]}\r\n\t */\r\n\tentries() {\r\n\t\treturn this._items.map((e) => [e.name, e]);\r\n\t}\r\n\r\n\t/**\r\n\t * Enumの全nameを返す\r\n\t * @returns {string[]}\r\n\t */\r\n\tkeys() {\r\n\t\treturn this._items.map((e) => e.name);\r\n\t}\r\n\r\n\t/**\r\n\t * name → value のマップを返す\r\n\t * @returns {Record<string, any>}\r\n\t */\r\n\ttoMap() {\r\n\t\tconst map = {};\r\n\t\tfor (const e of this._items) {\r\n\t\t\tmap[e.name] = e.value;\r\n\t\t}\r\n\t\treturn map;\r\n\t}\r\n\r\n\t/**\r\n\t * JSONシリアライズ用のtoJSONメソッド\r\n\t * @returns {Array<{name: string, ordinal: number, value: any}>} 列挙子の配列\r\n\t */\r\n\ttoJSON() {\r\n\t\treturn this._items.map((item) => item.toJSON());\r\n\t}\r\n\r\n\t/**\r\n\t * for...of に対応\r\n\t */\r\n\t*[Symbol.iterator]() {\r\n\t\tyield* this._items;\r\n\t}\r\n\r\n\t/**\r\n\t * インデックス付きで列挙子を返すジェネレータ\r\n\t * @returns {Generator<[number, _EnumItem]>} インデックスと列挙子のペア\r\n\t */\r\n\t*enumerate() {\r\n\t\tfor (let i = 0; i < this._items.length; i++) {\r\n\t\t\tyield [i, this._items[i]];\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * DynamicEnum生成関数（インデックスアクセスに対応したProxy付き）\r\n * @param {Array<string | [string, any]> | Record<string, any>} defs\r\n * @param {{[methodName: string]: (...args: any[]) => any}} [options.methods] - Enumのメソッド\r\n * @returns {_EnumCore & Proxy}\r\n */\r\nfunction Enum(defs, options = {}) {\r\n\tconst core = new _EnumCore(defs, options);\r\n\treturn new Proxy(core, {\r\n\t\tget(target, prop, receiver) {\r\n\t\t\tif (typeof prop === \"string\" && /^[0-9]+$/.test(prop)) {\r\n\t\t\t\tconst index = Number(prop);\r\n\t\t\t\treturn target._items[index];\r\n\t\t\t}\r\n\t\t\treturn Reflect.get(target, prop, receiver);\r\n\t\t},\r\n\r\n\t\tenumerate(target) {\r\n\t\t\t// 数字のインデックスを除外\r\n\t\t\treturn Object.keys(target._items).map((i) => i.toString());\r\n\t\t},\r\n\r\n\t\thas(target, prop) {\r\n\t\t\tif (typeof prop === \"string\" && /^[0-9]+$/.test(prop)) {\r\n\t\t\t\tconst index = Number(prop);\r\n\t\t\t\treturn index >= 0 && index < target._items.length;\r\n\t\t\t}\r\n\t\t\treturn prop in target;\r\n\t\t},\r\n\r\n\t\townKeys(target) {\r\n\t\t\tconst keys = Reflect.ownKeys(target);\r\n\t\t\tconst indexes = target._items.map((_, i) => i.toString());\r\n\t\t\treturn [...keys, ...indexes];\r\n\t\t},\r\n\r\n\t\tgetOwnPropertyDescriptor(target, prop) {\r\n\t\t\tif (typeof prop === \"string\" && /^[0-9]+$/.test(prop)) {\r\n\t\t\t\t// プロパティがターゲットに存在するか確認\r\n\t\t\t\tif (prop in target._items) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tvalue: target._items[Number(prop)],\r\n\t\t\t\t\t\twritable: false,\r\n\t\t\t\t\t\tconfigurable: false,\r\n\t\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\t};\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// プロパティが存在しない場合はエラーを避ける\r\n\t\t\t\t\treturn undefined; // これでエラーを避ける\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn Object.getOwnPropertyDescriptor(target, prop);\r\n\t\t},\r\n\r\n\t\tset(target, prop, value) {\r\n\t\t\tthrow new TypeError(`Enumは変更できません: ${String(prop)} = ${value}`);\r\n\t\t},\r\n\r\n\t\tdefineProperty(target, prop, descriptor) {\r\n\t\t\tthrow new TypeError(`Enumにプロパティを追加/変更できません: ${String(prop)}`);\r\n\t\t},\r\n\r\n\t\tdeleteProperty(target, prop) {\r\n\t\t\tthrow new TypeError(`Enumのプロパティを削除できません: ${String(prop)}`);\r\n\t\t},\r\n\t});\r\n}\r\n\r\nmodule.exports = {\r\n\t_EnumItem,\r\n\t_EnumCore,\r\n\tEnum,\r\n};\r\n",
    "const JavaLibraryScriptCore = require(\"../libs/sys/JavaLibraryScriptCore.js\");\r\nconst TypeChecker = require(\"../libs/TypeChecker.js\");\r\nconst { _EnumItem, Enum } = require(\"./Enum.js\");\r\n\r\n/**\r\n * @typedef {{throw: _EnumItem, log: _EnumItem, ignore: _EnumItem}} ErrorModeItem\r\n */\r\n//\r\n/**\r\n * @typedef {Object} InterfaceTypeData\r\n * @property {Function[] | null} [args] - 引数の型定義\r\n * @property {Function | Function[] | null} [returns] - 戻り値の型定義\r\n * @property {boolean} [abstract=true] - 抽象クラス化\r\n */\r\n//\r\n/**\r\n * @typedef {Object.<string, InterfaceTypeData>} InterfaceTypeDataList\r\n */\r\n//\r\n/**\r\n * インターフェイス管理\r\n * @extends {JavaLibraryScriptCore}\r\n * @class\r\n */\r\nclass Interface extends JavaLibraryScriptCore {\r\n\t/**\r\n\t * デバッグモード\r\n\t * @type {boolean}\r\n\t * @static\r\n\t */\r\n\tstatic _isDebugMode = false;\r\n\r\n\t/**\r\n\t * エラーモード\r\n\t * @type {ErrorModeItem}\r\n\t * @static\r\n\t * @readonly\r\n\t */\r\n\tstatic ErrorMode = Enum([\"throw\", \"log\", \"ignore\"]);\r\n\r\n\t/**\r\n\t * エラーモード\r\n\t * @type {ErrorModeItem}\r\n\t * @static\r\n\t */\r\n\tstatic _errorMode = this.ErrorMode.throw;\r\n\r\n\t/**\r\n\t * エラーモード設定\r\n\t * @param {ErrorModeItem} mode - エラーモード\r\n\t * @static\r\n\t */\r\n\tstatic setErrorMode(mode) {\r\n\t\tif (!this.ErrorMode.has(mode)) throw new Error(`不正な errorMode: ${mode}`);\r\n\t\tthis._errorMode = mode;\r\n\t}\r\n\r\n\t/**\r\n\t * エラー処理\r\n\t * @param {typeof Error} error\r\n\t * @param {string} message - エラーメッセージ\r\n\t * @static\r\n\t */\r\n\tstatic _handleError(error, message) {\r\n\t\tconst errorMode = this._errorMode;\r\n\t\tswitch (this._errorMode) {\r\n\t\t\tcase errorMode.throw:\r\n\t\t\t\tthrow new error(message);\r\n\t\t\tcase errorMode.log:\r\n\t\t\t\tconsole.warn(\"[Interface Warning]\", message);\r\n\t\t\t\tbreak;\r\n\t\t\tcase errorMode.ignore:\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * 型定義\r\n\t * @param {Function} TargetClass - 型定義を追加するクラス\r\n\t * @param {InterfaceTypeDataList} [newMethods] - 追加するメソッド群\r\n\t * @param {Object} [opt] - オプション\r\n\t * @param {boolean} [opt.inherit=true] - 継承モード\r\n\t * @returns {undefined}\r\n\t * @static\r\n\t */\r\n\tstatic applyTo(TargetClass, newDefs = {}, { inherit = true } = {}) {\r\n\t\tconst proto = TargetClass.prototype;\r\n\r\n\t\t// 継承モードなら親の型定義をマージ\r\n\t\tlet inheritedDefs = {};\r\n\t\tif (inherit) {\r\n\t\t\tconst parentProto = Object.getPrototypeOf(proto);\r\n\t\t\tif (parentProto && parentProto.__interfaceTypes) {\r\n\t\t\t\tinheritedDefs = { ...parentProto.__interfaceTypes };\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// クラスの型定義ストレージを用意 or 上書き\r\n\t\tif (!proto.__interfaceTypes) {\r\n\t\t\tObject.defineProperty(proto, \"__interfaceTypes\", {\r\n\t\t\t\tvalue: {},\r\n\t\t\t\tconfigurable: false,\r\n\t\t\t\twritable: false,\r\n\t\t\t\tenumerable: false,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// 継承＋新規定義マージ（子定義優先）\r\n\t\tObject.assign(proto.__interfaceTypes, inheritedDefs, newDefs);\r\n\t}\r\n\r\n\t/**\r\n\t * 型定義とメゾットの強制実装\r\n\t * @template T\r\n\t * @param {new (...args: any[]) => T} TargetClass - 型定義を追加するクラス\r\n\t * @param {InterfaceTypeDataList} [newMethods] - 追加するメソッド群\r\n\t * @param {Object} [opt] - オプション\r\n\t * @param {boolean} [opt.inherit=true] - 継承モード\r\n\t * @param {boolean} [opt.abstract=true] - 抽象クラス化\r\n\t * @returns {new (...args: any[]) => T}\r\n\t * @static\r\n\t */\r\n\tstatic convert(TargetClass, newDefs = {}, { inherit = true, abstract = true } = {}) {\r\n\t\tthis.applyTo(TargetClass, newDefs, { inherit });\r\n\r\n\t\tconst this_ = this;\r\n\r\n\t\tconst interfaceClass = class extends TargetClass {\r\n\t\t\tconstructor(...args) {\r\n\t\t\t\tif (abstract) {\r\n\t\t\t\t\tif (new.target === interfaceClass) {\r\n\t\t\t\t\t\tnew TypeError(`Cannot instantiate abstract class ${TargetClass.name}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tsuper(...args);\r\n\r\n\t\t\t\tif (!Interface._isDebugMode) return;\r\n\r\n\t\t\t\tconst proto = Object.getPrototypeOf(this);\r\n\t\t\t\tconst defs = proto.__interfaceTypes || {};\r\n\r\n\t\t\t\tfor (const methodName of Object.keys(defs)) {\r\n\t\t\t\t\tconst def = defs[methodName];\r\n\t\t\t\t\tconst original = this[methodName];\r\n\t\t\t\t\tconst isAbstract = !!def.abstract;\r\n\r\n\t\t\t\t\tif (typeof original !== \"function\") {\r\n\t\t\t\t\t\tif (isAbstract) continue;\r\n\t\t\t\t\t\tthis._handleError(Error, `\"${this.constructor.name}\" はメソッド \"${methodName}\" を実装する必要があります`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// ラップは一度だけ（重複防止）\r\n\t\t\t\t\tif (!original.__isWrapped) {\r\n\t\t\t\t\t\tconst wrapped = (...args) => {\r\n\t\t\t\t\t\t\t// 引数チェック\r\n\t\t\t\t\t\t\tconst expectedArgs = def.args || [];\r\n\t\t\t\t\t\t\tfor (let i = 0; i < expectedArgs.length; i++) {\r\n\t\t\t\t\t\t\t\tif (!TypeChecker.matchType(args[i], expectedArgs[i])) {\r\n\t\t\t\t\t\t\t\t\tthis_._handleError(TypeError, `\"${this.constructor.name}.${methodName}\" 第${i + 1}引数: ${TypeChecker.typeNames(expectedArgs[i])} を期待 → 実際: ${TypeChecker.stringify(args[i])}`);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tconst result = original.apply(this, args);\r\n\t\t\t\t\t\t\tconst expectedReturn = TypeChecker.checkFunction(def.returns) ? def.returns(args) : def.returns;\r\n\r\n\t\t\t\t\t\t\tconst validate = (val) => {\r\n\t\t\t\t\t\t\t\tif (!TypeChecker.matchType(val, expectedReturn)) {\r\n\t\t\t\t\t\t\t\t\tif (expectedReturn === TypeChecker.NoReturn) {\r\n\t\t\t\t\t\t\t\t\t\tthis_._handleError(TypeError, `\"${this.constructor.name}.${methodName}\" は戻り値を返してはいけません → 実際: ${TypeChecker.stringify(val)}`);\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tthis_._handleError(TypeError, `\"${this.constructor.name}.${methodName}\" の戻り値: ${TypeChecker.typeNames(expectedReturn)} を期待 → 実際: ${TypeChecker.stringify(val)}`);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn val;\r\n\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\treturn result instanceof Promise ? result.then(validate) : validate(result);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\twrapped.__isWrapped = true;\r\n\t\t\t\t\t\tthis[methodName] = wrapped;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tObject.defineProperty(interfaceClass, \"name\", { value: TargetClass.name });\r\n\r\n\t\treturn interfaceClass;\r\n\t}\r\n\r\n\t/**\r\n\t * 抽象メソッドが未実装かを個別に検査\r\n\t * @param {Object} instance\r\n\t * @returns {boolean}\r\n\t */\r\n\tstatic isAbstractImplemented(instance) {\r\n\t\tconst proto = Object.getPrototypeOf(instance);\r\n\t\tconst defs = proto.__interfaceTypes || {};\r\n\r\n\t\tfor (const [methodName, def] of Object.entries(defs)) {\r\n\t\t\tif (!def.abstract) continue;\r\n\t\t\tif (typeof instance[methodName] !== \"function\") return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * 型定義を取得\r\n\t * @param {Function|Object} ClassOrInstance\r\n\t * @returns {InterfaceTypeDataList}\r\n\t * @static\r\n\t */\r\n\tstatic getDefinition(ClassOrInstance) {\r\n\t\tconst proto = typeof ClassOrInstance === \"function\" ? ClassOrInstance.prototype : Object.getPrototypeOf(ClassOrInstance);\r\n\t\treturn proto.__interfaceTypes || {};\r\n\t}\r\n\r\n\t/**\r\n\t * 型定義を文字列化\r\n\t * @param {Function|Object} ClassOrInstance\r\n\t * @returns {string}\r\n\t * @static\r\n\t */\r\n\tstatic describe(ClassOrInstance) {\r\n\t\tconst defs = this.getDefinition(ClassOrInstance);\r\n\t\tconst lines = [];\r\n\t\tfor (const [name, def] of Object.entries(defs)) {\r\n\t\t\tconst argsStr = (def.args || []).map((t) => TypeChecker.typeNames(t)).join(\", \");\r\n\t\t\tconst retStr = TypeChecker.typeNames(def.returns);\r\n\t\t\tlines.push(`${def.abstract ? \"abstract \" : \"\"}function ${name}(${argsStr}) → ${retStr}`);\r\n\t\t}\r\n\t\treturn lines.join(\"\\n\");\r\n\t}\r\n\r\n\t/**\r\n\t * メソッド名を取得\r\n\t * @param {Function|Object} ClassOrInstance\r\n\t * @param {Object} [opt]\r\n\t * @param {boolean} [opt.abstractOnly=false]\r\n\t * @returns {string[]}\r\n\t * @static\r\n\t */\r\n\tstatic getMethodNames(ClassOrInstance, { abstractOnly = false } = {}) {\r\n\t\tconst defs = this.getDefinition(ClassOrInstance);\r\n\t\treturn Object.entries(defs)\r\n\t\t\t.filter(([_, def]) => !abstractOnly || def.abstract)\r\n\t\t\t.map(([name]) => name);\r\n\t}\r\n\r\n\t/**\r\n\t * メソッド定義を取得\r\n\t * @param {Function|Object} classOrInstance\r\n\t * @param {string} methodName\r\n\t * @returns {InterfaceTypeData | null}\r\n\t * @static\r\n\t */\r\n\tstatic getExpectedSignature(classOrInstance, methodName) {\r\n\t\tconst defs = this.getDefinition(classOrInstance);\r\n\t\tif (!(methodName in defs)) return null;\r\n\t\treturn {\r\n\t\t\targs: defs[methodName].args,\r\n\t\t\treturns: defs[methodName].returns,\r\n\t\t\tabstract: !!defs[methodName].abstract,\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * 型定義を結合\r\n\t * @param {...InterfaceTypeDataList} defs\r\n\t * @returns {InterfaceTypeDataList}\r\n\t * @static\r\n\t */\r\n\tstatic merge(...defs) {\r\n\t\tconst result = {};\r\n\t\tfor (const def of defs) {\r\n\t\t\tObject.assign(result, def);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n\r\nmodule.exports = Interface;\r\n",
    "module.exports = {\n    ...require(\"./Enum.js\"),\n    Interface: require(\"./Interface.js\")\n};\n",
    "module.exports = {\n    base: require(\"./base/index.js\"),\n    libs: require(\"./libs/index.js\"),\n    util: require(\"./util/index.js\")\n};\n",
    "const JavaLibraryScriptCore = require(\"../libs/sys/JavaLibraryScriptCore.js\");\r\nconst { _EnumCore, _EnumItem } = require(\"../base/Enum.js\");\r\n\r\n/**\r\n * 型チェッカー\r\n * @extends {JavaLibraryScriptCore}\r\n * @class\r\n */\r\nclass TypeChecker extends JavaLibraryScriptCore {\r\n\tstatic _CLASS_REG = /^\\s*class\\s+/;\r\n\r\n\t// ==================================================\r\n\t/**\r\n\t * Typeの否定\r\n\t * @extends {JavaLibraryScriptCore}\r\n\t * @class\r\n\t * @static\r\n\t */\r\n\tstatic _NotType = class _NotType extends JavaLibraryScriptCore {\r\n\t\t/**\r\n\t\t * @param {Function | Function[]} typeToExclude\r\n\t\t */\r\n\t\tconstructor(typeToExclude) {\r\n\t\t\tsuper();\r\n\t\t\tif (typeToExclude instanceof TypeChecker._NotType) throw new TypeError(\"typeToExclude must be instance of NotType\");\r\n\t\t\tthis.typeToExclude = typeToExclude;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * 否定型を返す\r\n\t * @param {Function | Function[]} typeToExclude\r\n\t * @returns {TypeChecker._NotType}\r\n\t */\r\n\tstatic NotType(typeToExclude) {\r\n\t\treturn new TypeChecker._NotType(typeToExclude);\r\n\t}\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 任意の型\r\n\t * @type {Symbol}\r\n\t * @static\r\n\t * @readonly\r\n\t */\r\n\tstatic Any = Symbol(\"any\");\r\n\t/**\r\n\t * 返り値を返さない関数の型\r\n\t * @type {Symbol}\r\n\t * @static\r\n\t * @readonly\r\n\t */\r\n\tstatic Void = Symbol(\"void\");\r\n\t/**\r\n\t * 返り値を返さない関数の型\r\n\t * @type {Symbol}\r\n\t * @static\r\n\t * @readonly\r\n\t */\r\n\tstatic NoReturn = this.Void;\r\n\r\n\t/**\r\n\t * null以外の型\r\n\t * @type {TypeChecker._NotType}\r\n\t * @static\r\n\t * @readonly\r\n\t */\r\n\tstatic NotNull = this.NotType(null);\r\n\t/**\r\n\t * undefined以外の型\r\n\t * @type {TypeChecker._NotType}\r\n\t * @static\r\n\t * @readonly\r\n\t */\r\n\tstatic NotUndefined = this.NotType(undefined);\r\n\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 型チェック(一括)\r\n\t * @param {any} value\r\n\t * @param {Function} expected\r\n\t * @returns {boolean}\r\n\t * @static\r\n\t */\r\n\tstatic matchType(value, expected) {\r\n\t\tif (Array.isArray(expected)) {\r\n\t\t\tconst notTypes = expected.filter((t) => t instanceof this._NotType);\r\n\t\t\tconst isNotExcluded = notTypes.some((t) => this.checkType(value, t.typeToExclude));\r\n\t\t\tif (isNotExcluded) return false;\r\n\t\t\tconst notExcluded = expected.filter((t) => !(t instanceof this._NotType));\r\n\t\t\tif (notExcluded.length === 0) return true;\r\n\t\t\treturn notExcluded.some((e) => this.checkType(value, e));\r\n\t\t}\r\n\t\treturn this.checkType(value, expected);\r\n\t}\r\n\r\n\t/**\r\n\t * 型チェック(個別)\r\n\t * @param {any} value\r\n\t * @param {Function} expected\r\n\t * @returns {boolean}\r\n\t * @static\r\n\t */\r\n\tstatic checkType(value, expected) {\r\n\t\tif (expected instanceof this._NotType) {\r\n\t\t\t// 除外型なので、valueが除外型にマッチしたらfalse\r\n\t\t\treturn !this.checkType(value, expected.typeToExclude);\r\n\t\t}\r\n\t\tif (expected === this.Any) return true;\r\n\t\tif (expected === this.NoReturn) return value === undefined;\r\n\t\tif (expected === null) return value === null;\r\n\t\tif (expected === undefined) return value === undefined;\r\n\t\tif (expected === String || expected === Number || expected === Boolean || expected === Symbol || expected === Function || expected === BigInt) return typeof value === expected.name.toLowerCase();\r\n\t\tif (expected === Object) return typeof value === \"object\" && value !== null && !Array.isArray(value);\r\n\t\tif (expected === Array) return Array.isArray(value);\r\n\t\t// ----- Enum対応\r\n\t\tif (expected instanceof _EnumCore) {\r\n\t\t\t// Enumの場合\r\n\t\t\treturn expected.has(value?.name);\r\n\t\t}\r\n\t\tif (expected === _EnumItem) return value instanceof _EnumItem;\r\n\t\t// -----\r\n\t\tif (typeof expected === \"function\") return value instanceof expected;\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * 型を取得する\r\n\t * @param {any} value\r\n\t * @returns {Function | null}\r\n\t */\r\n\tstatic getType(value) {\r\n\t\tif (value === null) return null;\r\n\t\tif (value === undefined) return undefined;\r\n\t\tconst type = typeof value;\r\n\t\tswitch (type) {\r\n\t\t\tcase \"string\":\r\n\t\t\t\treturn String;\r\n\t\t\tcase \"number\":\r\n\t\t\t\treturn Number;\r\n\t\t\tcase \"boolean\":\r\n\t\t\t\treturn Boolean;\r\n\t\t\tcase \"symbol\":\r\n\t\t\t\treturn Symbol;\r\n\t\t\tcase \"function\":\r\n\t\t\t\treturn Function;\r\n\t\t\tcase \"bigint\":\r\n\t\t\t\treturn BigInt;\r\n\t\t\tcase \"object\":\r\n\t\t\t\tif (Array.isArray(value)) return Array;\r\n\t\t\t\treturn value.constructor;\r\n\t\t}\r\n\t\tthrow new TypeError(`TypeChecker: getType()に対応していない型:${type}`);\r\n\t}\r\n\r\n\t/**\r\n\t * 型名を取得\r\n\t * @param {Function} expected\r\n\t * @returns {string}\r\n\t * @static\r\n\t */\r\n\tstatic typeNames(expected) {\r\n\t\tif (Array.isArray(expected)) return expected.map((t) => t?.name || TypeChecker.stringify(t)).join(\" | \");\r\n\t\treturn expected?.name || TypeChecker.stringify(expected);\r\n\t}\r\n\r\n\t/**\r\n\t * 値を文字列に変換\r\n\t * @param {any} value\r\n\t * @returns {string}\r\n\t * @static\r\n\t */\r\n\tstatic stringify(value) {\r\n\t\tif (value === null || value === undefined) {\r\n\t\t\treturn String(value);\r\n\t\t}\r\n\t\tif (typeof value === \"symbol\") {\r\n\t\t\tswitch (value) {\r\n\t\t\t\tcase this.Any:\r\n\t\t\t\t\treturn \"Any\";\r\n\t\t\t\tcase this.NoReturn:\r\n\t\t\t\tcase this.Void:\r\n\t\t\t\t\treturn \"NoReturn\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (typeof value === \"object\") {\r\n\t\t\tif (value?.toString() !== \"[object Object]\") {\r\n\t\t\t\treturn String(value);\r\n\t\t\t}\r\n\t\t\tif (value instanceof this._NotType) {\r\n\t\t\t\treturn `NotType(${TypeChecker.stringify(value.typeToExclude)})`;\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tconst jsonString = JSON.stringify(\r\n\t\t\t\t\tvalue,\r\n\t\t\t\t\t(key, val) => {\r\n\t\t\t\t\t\tif (val && typeof val === \"object\") {\r\n\t\t\t\t\t\t\tconst size = Object.keys(val).length;\r\n\t\t\t\t\t\t\t// オブジェクトが大きすぎる場合は省略表示\r\n\t\t\t\t\t\t\tif (size > 5) {\r\n\t\t\t\t\t\t\t\treturn `Object with ${size} properties`;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn val;\r\n\t\t\t\t\t},\r\n\t\t\t\t\t0\r\n\t\t\t\t);\r\n\t\t\t\t// JSON.stringifyエラー時にfallback\r\n\t\t\t\tif (jsonString === undefined) {\r\n\t\t\t\t\treturn \"Object is too large to display or contains circular references\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn jsonString.length > 1000 ? \"Object is too large to display\" : jsonString; // 文字数が多すぎる場合は省略\r\n\t\t\t} catch (e) {\r\n\t\t\t\treturn `[オブジェクト表示エラー: ${e.message}]`; // サークル参照等のエラー防止\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn String(value); // それ以外の型はそのまま文字列に変換\r\n\t}\r\n\r\n\t/**\r\n\t * 関数かチェック\r\n\t * @param {any} fn\r\n\t * @returns {boolean}\r\n\t * @static\r\n\t */\r\n\tstatic checkFunction(fn) {\r\n\t\tif (typeof fn !== \"function\") return false;\r\n\t\tif (this.checkClass(fn)) return false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * クラスかチェック\r\n\t * @param {any} fn\r\n\t * @returns {boolean}\r\n\t * @static\r\n\t */\r\n\tstatic checkClass(fn) {\r\n\t\tif (typeof fn !== \"function\") return false;\r\n\t\tif (this._CLASS_REG.test(fn.toString())) return true;\r\n\t\tif (fn === Function) return true;\r\n\t\ttry {\r\n\t\t\tnew new Proxy(fn, { construct: () => ({}) })();\r\n\t\t\treturn true;\r\n\t\t} catch {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = TypeChecker;\r\n",
    "module.exports = {\n    TypeChecker: require(\"./TypeChecker.js\"),\n    sys: require(\"./sys/index.js\")\n};\n",
    "/**\n * JavaLibraryScriptの共通継承元\n * @class\n */\nclass JavaLibraryScriptCore {\n\t/** @type {true} */\n\tstatic [Symbol.for(\"JavaLibraryScript\")] = true;\n}\n\nmodule.exports = JavaLibraryScriptCore;\n",
    "module.exports = {\n    JavaLibraryScriptCore: require(\"./JavaLibraryScriptCore.js\")\n};\n",
    "const JavaLibraryScript = require(\"./index.js\");\n\nif (typeof window !== \"undefined\") {\n\twindow.JavaLibraryScript = JavaLibraryScript;\n}\n\nmodule.exports = JavaLibraryScript;\n",
    "const { TypeChecker } = require(\"../libs\");\r\nconst MapInterface = require(\"./MapInterface\");\r\nconst EntryStream = require(\"./stream/EntryStream.js\");\r\n\r\n/**\r\n * 型チェック機能のついたMap\r\n * @template K, V\r\n * @extends {MapInterface<K, V>}\r\n * @class\r\n */\r\nclass HashMap extends MapInterface {\r\n\t/**\r\n\t * @param {Function} KeyType\r\n\t * @param {Function} ValueType\r\n\t */\r\n\tconstructor(KeyType, ValueType) {\r\n\t\tsuper(KeyType, ValueType);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// 基本操作(override)\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * データを追加・更新する\r\n\t * @param {K} key\r\n\t * @param {V} value\r\n\t * @returns {this}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tset(key, value) {\r\n\t\tthis._checkKey(key);\r\n\t\tthis._checkValue(value);\r\n\t\treturn super.set(key, value);\r\n\t}\r\n\t/**\r\n\t * データを追加・更新する\r\n\t * @param {K} key\r\n\t * @param {V} value\r\n\t * @returns {this}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tput(key, value) {\r\n\t\treturn this.set(key, value);\r\n\t}\r\n\r\n\t/**\r\n\t * データを一括で追加・更新する\r\n\t * @param {Map<K, V>} map\r\n\t * @throws {TypeError}\r\n\t */\r\n\tsetAll(map) {\r\n\t\tfor (const [k, v] of map.entries()) {\r\n\t\t\tthis.set(k, v);\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * データを一括で追加・更新する\r\n\t * @param {Map<K, V>} map\r\n\t * @throws {TypeError}\r\n\t */\r\n\tputAll(map) {\r\n\t\treturn this.setAll(map);\r\n\t}\r\n\r\n\t/**\r\n\t * データを取得する\r\n\t * @param {K} key\r\n\t * @returns {V}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tget(key) {\r\n\t\tthis._checkKey(key);\r\n\t\treturn super.get(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Keyの存在を確認する\r\n\t * @param {K} key\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\thas(key) {\r\n\t\tthis._checkKey(key);\r\n\t\treturn super.has(key);\r\n\t}\r\n\t/**\r\n\t * Keyの存在を確認する\r\n\t * @param {K} key\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tcontainsKey(key) {\r\n\t\treturn this.has(key);\r\n\t}\r\n\r\n\t/**\r\n\t * Valueの存在を確認する\r\n\t * @param {V} value\r\n\t * @returns {boolean}\r\n\t */\r\n\tcontainsValue(value) {\r\n\t\tfor (const v of super.values()) {\r\n\t\t\tif (v === value) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * データを削除する\r\n\t * @param {K} key\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tdelete(key) {\r\n\t\tthis._checkKey(key);\r\n\t\treturn super.delete(key);\r\n\t}\r\n\t/**\r\n\t * データを削除する\r\n\t * @param {K} key\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tremove(key) {\r\n\t\treturn this.delete(key);\r\n\t}\r\n\r\n\t/**\r\n\t * EntrySetを返却する\r\n\t * @returns {MapIterator<[...[K, V]]>}\r\n\t */\r\n\tentrySet() {\r\n\t\treturn this.entries();\r\n\t}\r\n\r\n\t/**\r\n\t * 空かどうかを返却する\r\n\t * @returns {boolean}\r\n\t */\r\n\tisEmpty() {\r\n\t\treturn super.size === 0;\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// 追加機能\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 等価判定を行う\r\n\t * @param {this} otherMap\r\n\t * @returns {boolean}\r\n\t */\r\n\tequals(otherMap) {\r\n\t\tif (!(otherMap instanceof Map) || this.size !== otherMap.size) return false;\r\n\t\tfor (const [k, v] of this.entries()) {\r\n\t\t\tif (!otherMap.has(k) || otherMap.get(k) !== v) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * 全てのデータを呼び出す\r\n\t * @param {Function} callback\r\n\t * @param {any} thisArg\r\n\t */\r\n\tforEach(callback, thisArg) {\r\n\t\tfor (const [key, value] of this.entries()) {\r\n\t\t\tcallback.call(thisArg, value, key, this);\r\n\t\t}\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// Stream\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * Streamを返却する\r\n\t * @returns {EntryStream<K, V>}\r\n\t */\r\n\tstream() {\r\n\t\treturn EntryStream.from(this.entries(), this._KeyType, this._ValueType);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// 基本操作(システム)\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 文字列に変換する\r\n\t * @returns {string}\r\n\t */\r\n\ttoString() {\r\n\t\treturn `${this.constructor.name}<${TypeChecker.typeNames(this._KeyType)}, ${TypeChecker.typeNames(this._ValueType)}>(size=${this.size})`;\r\n\t}\r\n\r\n\t/**\r\n\t * イテレータを返却する\r\n\t * @returns {Iterator<V>}\r\n\t */\r\n\t[Symbol.iterator]() {\r\n\t\treturn this.entries();\r\n\t}\r\n}\r\n\r\nmodule.exports = HashMap;\r\n",
    "const SetInterface = require(\"./SetInterface\");\r\nconst TypeChecker = require(\"../libs/TypeChecker\");\r\nconst StreamChecker = require(\"./stream/StreamChecker\");\r\nconst Stream = require(\"./stream/Stream.js\");\r\n\r\n/**\r\n * 型チェック機能のついたMap\r\n * @template V\r\n * @extends {SetInterface<V>}\r\n * @class\r\n */\r\nclass HashSet extends SetInterface {\r\n\t/**\r\n\t * @param {Function} ValueType\r\n\t */\r\n\tconstructor(ValueType) {\r\n\t\tsuper(ValueType);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// 基本操作(override)\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 値を追加する\r\n\t * @param {V} value\r\n\t * @returns {this}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tadd(value) {\r\n\t\tthis._checkValue(value);\r\n\t\treturn super.add(value);\r\n\t}\r\n\r\n\t/**\r\n\t * 値を一括で追加する\r\n\t * @param {Iterable<V>} collection\r\n\t * @returns {this}\r\n\t * @throws {TypeError}\r\n\t */\r\n\taddAll(collection) {\r\n\t\tfor (const item of collection) {\r\n\t\t\tthis.add(item);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * 値の存在を確認\r\n\t * @param {V} value\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\thas(value) {\r\n\t\tthis._checkValue(value);\r\n\t\treturn super.has(value);\r\n\t}\r\n\t/**\r\n\t * 値の存在を確認\r\n\t * @param {V} value\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tcontains(value) {\r\n\t\treturn this.has(value);\r\n\t}\r\n\r\n\t/**\r\n\t * 全ての値の存在を確認\r\n\t * @param {Iterable<V>} collection\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tcontainsAll(collection) {\r\n\t\tfor (const item of collection) {\r\n\t\t\tif (!this.has(item)) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * 値を削除する\r\n\t * @param {V} value\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tdelete(value) {\r\n\t\tthis._checkValue(value);\r\n\t\treturn super.delete(value);\r\n\t}\r\n\t/**\r\n\t * 値を削除する\r\n\t * @param {V} value\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tremove(value) {\r\n\t\treturn this.delete(value);\r\n\t}\r\n\r\n\t/**\r\n\t * 全ての値を削除する\r\n\t * @param {Iterable<V>} collection\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tremoveAll(collection) {\r\n\t\tlet modified = false;\r\n\t\tfor (const item of collection) {\r\n\t\t\tmodified = this.delete(item) || modified;\r\n\t\t}\r\n\t\treturn modified;\r\n\t}\r\n\r\n\t/**\r\n\t * 空かどうかを返却する\r\n\t * @returns {boolean}\r\n\t */\r\n\tisEmpty() {\r\n\t\treturn this.size === 0;\r\n\t}\r\n\r\n\t/**\r\n\t * 含まれない要素を全削除する\r\n\t * @param {Iterable<V>} collection\r\n\t * @returns {boolean}\r\n\t * @throws {TypeError}\r\n\t */\r\n\tretainAll(collection) {\r\n\t\tconst otherSet = new Set(collection);\r\n\t\tlet modified = false;\r\n\t\tfor (const item of this) {\r\n\t\t\tif (!otherSet.has(item)) {\r\n\t\t\t\tthis.delete(item);\r\n\t\t\t\tmodified = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn modified;\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// 追加機能\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 等価判定を行う\r\n\t * @param {this} otherSet\r\n\t * @returns {boolean}\r\n\t */\r\n\tequals(otherSet) {\r\n\t\tif (!(otherSet instanceof Set) || this.size !== otherSet.size) return false;\r\n\t\tfor (const item of this) {\r\n\t\t\tif (!otherSet.has(item)) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * 全てのデータを呼び出す\r\n\t * @param {Function} callback\r\n\t * @param {any} [thisArg]\r\n\t */\r\n\tforEach(callback, thisArg) {\r\n\t\tfor (const item of this) {\r\n\t\t\tcallback.call(thisArg, item, item, this);\r\n\t\t}\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// Stream\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * Streamを返却する\r\n\t * @returns {Stream<V>}\r\n\t */\r\n\tstream() {\r\n\t\treturn StreamChecker.typeToStream(this._ValueType).from(this.values(), this._ValueType);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// 基本操作(システム)\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 配列に変換する\r\n\t * @returns {V[]}\r\n\t */\r\n\ttoArray() {\r\n\t\treturn Array.from(this);\r\n\t}\r\n\r\n\t/**\r\n\t * 文字列に変換する\r\n\t * @returns {string}\r\n\t */\r\n\ttoString() {\r\n\t\treturn `${this.constructor.name}<${TypeChecker.typeNames(this._ValueType)}>(size=${this.size})`;\r\n\t}\r\n\r\n\t/**\r\n\t * イテレータを返却する\r\n\t * @returns {Iterator<V>}\r\n\t */\r\n\t[Symbol.iterator]() {\r\n\t\treturn this.values();\r\n\t}\r\n}\r\n\r\nmodule.exports = HashSet;\r\n",
    "const Interface = require(\"../base/Interface\");\nconst TypeChecker = require(\"../libs/TypeChecker\");\n\nconst Any = TypeChecker.Any;\nconst NoReturn = TypeChecker.NoReturn;\nconst NotNull = TypeChecker.NotNull;\nconst NotUndefined = TypeChecker.NotUndefined;\n\nconst NotEmpty = [NotNull, NotUndefined];\n\n/**\n * Mapの基底クラス\n * @template K, V\n * @extends {Map<K, V>}\n * @class\n * @abstract\n * @interface\n */\nclass MapInterface extends Map {\n\t/**\n\t * @param {Function} KeyType\n\t * @param {Function} ValueType\n\t */\n\tconstructor(KeyType, ValueType) {\n\t\tsuper();\n\t\tthis._KeyType = KeyType || Any;\n\t\tthis._ValueType = ValueType || Any;\n\t}\n\n\t/**\n\t * Keyの型をチェックする\n\t * @param {K} key\n\t * @throws {TypeError}\n\t */\n\t_checkKey(key) {\n\t\tif (!TypeChecker.matchType(key, this._KeyType)) {\n\t\t\tthrow new TypeError(`キー型が一致しません。期待: ${TypeChecker.typeNames(this._KeyType)} → 実際: ${TypeChecker.stringify(key)}`);\n\t\t}\n\t}\n\n\t/**\n\t * Valueの型をチェックする\n\t * @param {V} value\n\t * @throws {TypeError}\n\t */\n\t_checkValue(value) {\n\t\tif (!TypeChecker.matchType(value, this._ValueType)) {\n\t\t\tthrow new TypeError(`値型が一致しません。期待: ${TypeChecker.typeNames(this._ValueType)} → 実際: ${TypeChecker.stringify(value)}`);\n\t\t}\n\t}\n}\n\nmodule.exports = Interface.convert(MapInterface, {\n\tset: { args: [NotEmpty, NotEmpty], returns: Any, abstract: true },\n\tput: { args: [NotEmpty, NotEmpty], returns: Any },\n\tget: { args: [NotEmpty], returns: Any, abstract: true },\n\tdelete: { args: [NotEmpty], returns: Boolean, abstract: true },\n\tremove: { args: [NotEmpty], returns: Boolean },\n\tisEmpty: { returns: Boolean },\n\tclear: { returns: NoReturn },\n\thas: { args: [NotEmpty], returns: Boolean, abstract: true },\n\tcontainsKey: { args: [NotEmpty], returns: Boolean },\n\tcontainsValue: { args: [NotEmpty], returns: Boolean },\n});\n",
    "const Interface = require(\"../base/Interface\");\nconst TypeChecker = require(\"../libs/TypeChecker\");\n\nconst Any = TypeChecker.Any;\nconst NoReturn = TypeChecker.NoReturn;\nconst NotNull = TypeChecker.NotNull;\nconst NotUndefined = TypeChecker.NotUndefined;\n\nconst NotEmpty = [NotNull, NotUndefined];\n\n/**\n * Setの基底クラス\n * @template V\n * @extends {Set<V>}\n * @class\n * @abstract\n * @interface\n */\nclass SetInterface extends Set {\n\t/**\n\t * @param {Function} ValueType\n\t */\n\tconstructor(ValueType) {\n\t\tsuper();\n\t\tthis._ValueType = ValueType || Any;\n\t}\n\n\t/**\n\t * Valueの型をチェックする\n\t * @param {V} value\n\t * @throws {TypeError}\n\t */\n\t_checkValue(value) {\n\t\tif (!TypeChecker.matchType(value, this._ValueType)) {\n\t\t\tthrow new TypeError(`値型が一致しません。期待: ${TypeChecker.typeNames(this._ValueType)} → 実際: ${TypeChecker.stringify(value)}`);\n\t\t}\n\t}\n}\n\nmodule.exports = Interface.convert(SetInterface, {\n\tadd: { args: [NotEmpty], returns: Any },\n\tdelete: { args: [NotEmpty], returns: Boolean },\n\tremove: { args: [NotEmpty], returns: Boolean },\n\tisEmpty: { returns: Boolean },\n\tclear: { returns: NoReturn },\n\thas: { args: [NotEmpty], returns: Boolean },\n\tcontains: { args: [NotEmpty], returns: Boolean },\n});\n",
    "module.exports = {\n    HashMap: require(\"./HashMap.js\"),\n    HashSet: require(\"./HashSet.js\"),\n    MapInterface: require(\"./MapInterface.js\"),\n    SetInterface: require(\"./SetInterface.js\"),\n    stream: require(\"./stream/index.js\")\n};\n",
    "const StreamInterface = require(\"./StreamInterface.js\");\r\nconst Stream = require(\"./Stream.js\");\r\n\r\n/**\r\n * 非同期Stream (LazyAsyncList)\r\n * @extends {StreamInterface}\r\n * @class\r\n */\r\nclass AsyncStream extends StreamInterface {\r\n\t/**\r\n\t * @param {Iterable | AsyncIterator} source\r\n\t */\r\n\tconstructor(source) {\r\n\t\tsuper();\r\n\t\tthis._iter = AsyncStream._normalize(source);\r\n\t\tthis._pipeline = [];\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStream化\r\n\t * @template {AsyncStream} T\r\n\t * @this {new (iterable: Iterable | AsyncIterator) => T}\r\n\t * @param {Iterable | AsyncIterator} iterable\r\n\t * @returns {T}\r\n\t * @static\r\n\t */\r\n\tstatic from(iterable) {\r\n\t\treturn new AsyncStream(iterable);\r\n\t}\r\n\r\n\t/**\r\n\t * Iterable化\r\n\t * @param {Iterable | AsyncIterator} input\r\n\t * @returns {AsyncIterator}\r\n\t */\r\n\tstatic _normalize(input) {\r\n\t\tif (typeof input[Symbol.asyncIterator] === \"function\") return input;\r\n\t\tif (typeof input[Symbol.iterator] === \"function\") {\r\n\t\t\treturn (async function* () {\r\n\t\t\t\tfor (const x of input) yield x;\r\n\t\t\t})();\r\n\t\t}\r\n\t\tthrow new TypeError(\"not (Async)Iterable\");\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// パイプライン計算\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * pipelineに追加\r\n\t * @param {Generator} fn\r\n\t * @returns {this}\r\n\t */\r\n\t_use(fn) {\r\n\t\tthis._pipeline.push(fn);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * pipelineを圧縮\r\n\t * @returns {this}\r\n\t */\r\n\tflattenPipeline() {\r\n\t\tconst flattenedFn = this._pipeline.reduceRight(\r\n\t\t\t(nextFn, currentFn) => {\r\n\t\t\t\treturn async function* (iterable) {\r\n\t\t\t\t\tyield* currentFn(nextFn(iterable));\r\n\t\t\t\t};\r\n\t\t\t},\r\n\t\t\tasync function* (x) {\r\n\t\t\t\tyield* x;\r\n\t\t\t}\r\n\t\t);\r\n\t\tconst flat = new this.constructor([]);\r\n\t\tflat._iter = this._iter;\r\n\t\tflat._pipeline = [flattenedFn];\r\n\t\treturn flat;\r\n\t}\r\n\r\n\t/**\r\n\t * 処理を一括関数化\r\n\t * @returns {Function}\r\n\t */\r\n\ttoFunction() {\r\n\t\tconst flat = this.flattenPipeline();\r\n\t\tconst fn = flat._pipeline[0];\r\n\t\treturn (input) => fn(input);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// Pipeline\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * AsyncStreamをマップ\r\n\t * @param {Function | Promise} fn\r\n\t * @returns {this}\r\n\t */\r\n\tmap(fn) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tfor await (const x of iter) yield await fn(x);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamをフィルタ\r\n\t * @param {Function | Promise} fn\r\n\t * @returns {this}\r\n\t */\r\n\tfilter(fn) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tfor await (const x of iter) {\r\n\t\t\t\tif (await fn(x)) yield x;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamを展開\r\n\t * @param {Function | Promise} fn\r\n\t * @returns {this}\r\n\t */\r\n\tflatMap(fn) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tfor await (const x of iter) {\r\n\t\t\t\tconst sub = await fn(x);\r\n\t\t\t\tfor await (const y of AsyncStream._normalize(sub)) yield y;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamの重複を排除\r\n\t * @param {Function | Promise} keyFn\r\n\t * @returns {this}\r\n\t */\r\n\tdistinct(keyFn = (x) => x) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tconst seen = new Set();\r\n\t\t\tfor await (const x of iter) {\r\n\t\t\t\tconst key = await keyFn(x);\r\n\t\t\t\tif (!seen.has(key)) {\r\n\t\t\t\t\tseen.add(key);\r\n\t\t\t\t\tyield x;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamの要素は変更せずに関数のみを実行\r\n\t * @param {Function} fn\r\n\t * @returns {this}\r\n\t */\r\n\tpeek(fn) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tfor await (const x of iter) {\r\n\t\t\t\tfn(x);\r\n\t\t\t\tyield x;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamの要素数を先頭から制限\r\n\t * @param {Number} n\r\n\t * @returns {this}\r\n\t */\r\n\tlimit(n) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tlet i = 0;\r\n\t\t\tfor await (const x of iter) {\r\n\t\t\t\tif (i++ < n) yield x;\r\n\t\t\t\telse break;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamの要素数を先頭からスキップ\r\n\t * @param {Number} n\r\n\t * @returns {this}\r\n\t */\r\n\tskip(n) {\r\n\t\treturn this._use(async function* (iter) {\r\n\t\t\tlet i = 0;\r\n\t\t\tfor await (const x of iter) {\r\n\t\t\t\tif (i++ >= n) yield x;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// Iterator\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * Streamをイテレータ化(非同期)\r\n\t * @returns {AsyncIterator}\r\n\t */\r\n\t[Symbol.asyncIterator]() {\r\n\t\tlet iter = this._iter;\r\n\t\tfor (const op of this._pipeline) {\r\n\t\t\titer = op(iter);\r\n\t\t}\r\n\t\treturn iter[Symbol.asyncIterator]();\r\n\t}\r\n\t// ==================================================\r\n\t// End\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * AsyncStreamをforEach\r\n\t * @param {Function | Promise} fn\r\n\t * @async\r\n\t */\r\n\tasync forEach(fn) {\r\n\t\tfor await (const x of this) {\r\n\t\t\tawait fn(x);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamを配列化\r\n\t * @returns {Array}\r\n\t * @async\r\n\t */\r\n\tasync toArray() {\r\n\t\tconst result = [];\r\n\t\tfor await (const x of this) {\r\n\t\t\tresult.push(x);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamをreduce\r\n\t * @param {Function | Promise} fn\r\n\t * @param {any} initial\r\n\t * @returns {any}\r\n\t * @async\r\n\t */\r\n\tasync reduce(fn, initial) {\r\n\t\tlet acc = initial;\r\n\t\tfor await (const x of this) {\r\n\t\t\tacc = await fn(acc, x);\r\n\t\t}\r\n\t\treturn acc;\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamの要素数を取得\r\n\t * @returns {Number}\r\n\t * @async\r\n\t */\r\n\tasync count() {\r\n\t\treturn await this.reduce((acc) => acc + 1, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamで条件を満たす要素があるか検査\r\n\t * @param {Function | Promise} fn\r\n\t * @returns {Boolean}\r\n\t * @async\r\n\t */\r\n\tasync some(fn) {\r\n\t\tfor await (const x of this) {\r\n\t\t\tif (await fn(x)) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamで全ての要素が条件を満たすか検査\r\n\t * @param {Function | Promise} fn\r\n\t * @returns {Boolean}\r\n\t * @async\r\n\t */\r\n\tasync every(fn) {\r\n\t\tfor await (const x of this) {\r\n\t\t\tif (!(await fn(x))) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * AsyncStreamから最初の要素を取得\r\n\t * @returns {any}\r\n\t * @async\r\n\t */\r\n\tasync findFirst() {\r\n\t\tfor await (const item of this) return item;\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamから任意の要素を取得\r\n\t * @returns {any}\r\n\t * @async\r\n\t */\r\n\tasync find() {\r\n\t\treturn await this.findFirst();\r\n\t}\r\n\r\n\t/**\r\n\t * Java Collectors 相当\r\n\t * @param {Function} collectorFn\r\n\t * @returns {any}\r\n\t */\r\n\tcollectWith(collectorFn) {\r\n\t\treturn collectorFn(this);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// mapTo\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * AsyncStreamをStreamに変換\r\n\t * @returns {Stream}\r\n\t * @async\r\n\t */\r\n\tasync toLazy() {\r\n\t\tconst arr = [];\r\n\t\tfor await (const item of this) {\r\n\t\t\tarr.push(item);\r\n\t\t}\r\n\t\treturn new Stream(arr);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// その他\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * 文字列に変換する\r\n\t * @returns {String}\r\n\t */\r\n\ttoString() {\r\n\t\treturn `${this.constructor.name}<Promise>`;\r\n\t}\r\n}\r\n\r\nmodule.exports = AsyncStream;\r\n",
    "const Stream = require(\"./Stream.js\");\nconst StreamChecker = require(\"./StreamChecker\");\nconst TypeChecker = require(\"../../libs/TypeChecker\");\n\n/** @typedef {import(\"../HashMap.js\")} HashMapType */\n\nconst Any = TypeChecker.Any;\n\nlet HashMap;\nfunction init() {\n\tif (HashMap) return;\n\tHashMap = require(\"../HashMap.js\");\n}\n\n/**\n * Entry専用Stream (LazyList)\n * @template K, V\n * @extends {Stream}\n * @class\n */\nclass EntryStream extends Stream {\n\t/**\n\t * @param {Iterable} source\n\t * @param {Function} KeyType\n\t * @param {Function} ValueType\n\t */\n\tconstructor(source, KeyType, ValueType) {\n\t\tsuper(source, ValueType);\n\n\t\tthis.mapToEntry = undefined;\n\t\tthis._KeyType = KeyType || Any;\n\t}\n\n\t/**\n\t * Stream化\n\t * @template {EntryStream} T\n\t * @this {new (Iterable, Function, Function) => T}\n\t * @param {Iterable} iterable\n\t * @param {Function} KeyType\n\t * @param {Function} ValueType\n\t * @returns {T}\n\t * @overload\n\t * @static\n\t */\n\tstatic from(iterable, KeyType, ValueType) {\n\t\treturn new this(iterable, KeyType, ValueType);\n\t}\n\n\t/**\n\t * EntryStreamからキーのStreamを返却\n\t * @returns {Stream}\n\t */\n\tkeys() {\n\t\treturn this._convertToX(StreamChecker.typeToStream(this._KeyType)).map(([k, _]) => k);\n\t}\n\n\t/**\n\t * EntryStreamから値のStreamを返却\n\t * @returns {Stream}\n\t */\n\tvalues() {\n\t\treturn this._convertToX(StreamChecker.typeToStream(this._ValueType)).map(([_, v]) => v);\n\t}\n\n\t/**\n\t * EntryStreamのキーをマップ\n\t * @param {Function} fn\n\t * @returns {this}\n\t */\n\tmapKeys(fn) {\n\t\treturn this.map(([k, v]) => [fn(k), v]);\n\t}\n\n\t/**\n\t * EntryStreamの値をマップ\n\t * @param {Function} fn\n\t * @returns {this}\n\t */\n\tmapValues(fn) {\n\t\treturn this.map(([k, v]) => [k, fn(v)]);\n\t}\n\n\t// ==================================================\n\t// to\n\t// ==================================================\n\n\t/**\n\t * EntryStreamをHashMapに変換する\n\t * @param {Function} [KeyType]\n\t * @param {Function} [ValueType]\n\t * @returns {HashMapType}\n\t */\n\ttoHashMap(KeyType = this._KeyType, ValueType = this._ValueType) {\n\t\tinit();\n\t\tconst map = new HashMap(KeyType, ValueType);\n\t\tthis.forEach(([k, v]) => map.set(k, v));\n\t\treturn map;\n\t}\n\n\t/**\n\t * 文字列に変換する\n\t * @returns {String}\n\t * @override\n\t */\n\ttoString() {\n\t\treturn `${this.constructor.name}<${TypeChecker.typeNames(this._KeyType)}, ${TypeChecker.typeNames(this._ValueType)}>`;\n\t}\n}\n\nmodule.exports = EntryStream;\n",
    "const Stream = require(\"./Stream.js\");\n\n/**\n * 数値専用Stream (LazyList)\n * @template V\n * @extends {Stream}\n * @class\n */\nclass NumberStream extends Stream {\n\t/**\n\t * @param {Iterable<V} source\n\t */\n\tconstructor(source) {\n\t\tsuper(source, Number);\n\n\t\tthis.mapToNumber = undefined;\n\t}\n\n\t/**\n\t * 合計\n\t * @returns {Number}\n\t */\n\tsum() {\n\t\tlet total = 0;\n\t\tfor (const num of this) {\n\t\t\ttotal += num;\n\t\t}\n\t\treturn total;\n\t}\n\n\t/**\n\t * 平均\n\t * @returns {Number}\n\t */\n\taverage() {\n\t\tlet total = 0;\n\t\tlet count = 0;\n\t\tfor (const num of this) {\n\t\t\ttotal += num;\n\t\t\tcount++;\n\t\t}\n\t\treturn count === 0 ? NaN : total / count;\n\t}\n\n\t/**\n\t * 最小値\n\t * @returns {Number | null}\n\t */\n\tmin() {\n\t\tlet min = Infinity;\n\t\tfor (const num of this) {\n\t\t\tif (num < min) min = num;\n\t\t}\n\t\treturn min === Infinity ? null : min;\n\t}\n\n\t/**\n\t * 最大値\n\t * @returns {Number | null}\n\t */\n\tmax() {\n\t\tlet max = -Infinity;\n\t\tfor (const num of this) {\n\t\t\tif (num > max) max = num;\n\t\t}\n\t\treturn max === -Infinity ? null : max;\n\t}\n}\n\nmodule.exports = NumberStream;\n",
    "const StreamInterface = require(\"./StreamInterface.js\");\r\nconst TypeChecker = require(\"../../libs/TypeChecker\");\r\n\r\nconst Any = TypeChecker.Any;\r\n\r\n/** @typedef {import(\"./NumberStream.js\")} NumberStreamType */\r\n// /** @typedef {import(\"./StringStream.js\")} StringStream_forceRep */ // なぜかこいつだけ動かん\r\n/** @typedef {import(\"./EntryStream.js\")} EntryStreamType */\r\n/** @typedef {import(\"./AsyncStream.js\")} AsyncStreamType */\r\n/** @typedef {import(\"../HashSet.js\")} HashSetType */\r\n\r\nlet NumberStream, StringStream, EntryStream, AsyncStream, HashSet;\r\nfunction init() {\r\n\tif (NumberStream) return;\r\n\tNumberStream = require(\"./NumberStream.js\");\r\n\tStringStream = require(\"./StringStream.js\");\r\n\tEntryStream = require(\"./EntryStream.js\");\r\n\tAsyncStream = require(\"./AsyncStream.js\");\r\n\tHashSet = require(\"../HashSet.js\");\r\n}\r\n\r\n/**\r\n * Streamオブジェクト(LazyList)\r\n * @template V\r\n * @extends {StreamInterface}\r\n * @class\r\n */\r\nclass Stream extends StreamInterface {\r\n\t/**\r\n\t * @param {Iterable<V>} source\r\n\t * @param {Function} ValueType\r\n\t */\r\n\tconstructor(source, ValueType) {\r\n\t\tsuper();\r\n\t\tthis._iter = source[Symbol.iterator]();\r\n\t\tthis._pipeline = [];\r\n\r\n\t\tthis._ValueType = ValueType || Any;\r\n\r\n\t\tinit();\r\n\t}\r\n\r\n\t/**\r\n\t * Stream化\r\n\t * @template {Stream} T\r\n\t * @this {new (Iterable) => T}\r\n\t * @param {Iterable<V>} iterable\r\n\t * @param {Function} ValueType\r\n\t * @returns {T}\r\n\t * @static\r\n\t */\r\n\tstatic from(iterable, ValueType) {\r\n\t\treturn new this(iterable, ValueType);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// パイプライン計算\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * pipelineに追加\r\n\t * @param {Generator} fn\r\n\t * @returns {this}\r\n\t */\r\n\t_use(fn) {\r\n\t\tthis._pipeline.push(fn);\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * 他Streamに変換\r\n\t * @param {Function} construct\r\n\t * @param {Generator} fn\r\n\t * @param {...any} args\r\n\t * @returns {this}\r\n\t */\r\n\t_convertToX(construct, fn, ...args) {\r\n\t\tconst newStream = new construct([], ...args);\r\n\t\tnewStream._iter = this._iter;\r\n\t\tnewStream._pipeline = [...this._pipeline];\r\n\t\tif (fn) newStream._pipeline.push(fn);\r\n\t\treturn newStream;\r\n\t}\r\n\r\n\t/**\r\n\t * pipelineを圧縮\r\n\t * @returns {this}\r\n\t */\r\n\tflattenPipeline() {\r\n\t\tconst flattenedFn = this._pipeline.reduceRight(\r\n\t\t\t(nextFn, currentFn) => {\r\n\t\t\t\treturn function* (iterable) {\r\n\t\t\t\t\tyield* currentFn(nextFn(iterable));\r\n\t\t\t\t};\r\n\t\t\t},\r\n\t\t\t(x) => x\r\n\t\t);\r\n\r\n\t\tconst flat = new this.constructor([]); // 継承クラス対応\r\n\t\tflat._iter = this._iter;\r\n\t\tflat._pipeline = [flattenedFn];\r\n\t\treturn flat;\r\n\t}\r\n\r\n\t/**\r\n\t * 処理を一括関数化\r\n\t * @returns {Function}\r\n\t */\r\n\ttoFunction() {\r\n\t\tconst flat = this.flattenPipeline();\r\n\t\tconst fn = flat._pipeline[0];\r\n\t\treturn (input) => fn(input);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// Pipeline\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * Streamをマップ\r\n\t * @param {Function} fn\r\n\t * @returns {this}\r\n\t */\r\n\tmap(fn) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tfor (const item of iter) yield fn(item);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamをフィルタ\r\n\t * @param {Function} fn\r\n\t * @returns {this}\r\n\t */\r\n\tfilter(fn) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tfor (const item of iter) if (fn(item)) yield item;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamを展開\r\n\t * @param {Function} fn\r\n\t * @returns {this}\r\n\t */\r\n\tflatMap(fn) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tconst sub = fn(item);\r\n\t\t\t\tyield* sub instanceof StreamInterface ? sub : sub[Symbol.iterator]();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamの重複を排除\r\n\t * @param {Function} keyFn\r\n\t * @returns {this}\r\n\t */\r\n\tdistinct(keyFn = JSON.stringify.bind(JSON)) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tconst seen = new Set();\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tconst key = keyFn(item);\r\n\t\t\t\tif (!seen.has(key)) {\r\n\t\t\t\t\tseen.add(key);\r\n\t\t\t\t\tyield item;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamをソート\r\n\t * @param {Function} compareFn\r\n\t * @returns {this}\r\n\t */\r\n\tsorted(compareFn = (a, b) => (a > b ? 1 : a < b ? -1 : 0)) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tconst arr = [...iter].sort(compareFn);\r\n\t\t\tyield* arr;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamの要素は変更せずに関数のみを実行\r\n\t * @param {Function} fn\r\n\t * @returns {this}\r\n\t */\r\n\tpeek(fn) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tfn(item);\r\n\t\t\t\tyield item;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamの要素数を先頭から制限\r\n\t * @param {Number} n\r\n\t * @returns {this}\r\n\t */\r\n\tlimit(n) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tlet i = 0;\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tif (i++ >= n) break;\r\n\t\t\t\tyield item;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamの要素数を先頭からスキップ\r\n\t * @param {Number} n\r\n\t * @returns {this}\r\n\t */\r\n\tskip(n) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tlet i = 0;\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tif (i++ < n) continue;\r\n\t\t\t\tyield item;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamを分割\r\n\t * @param {Number} size\r\n\t * @returns {this}\r\n\t */\r\n\tchunk(size) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tlet buf = [];\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tbuf.push(item);\r\n\t\t\t\tif (buf.length === size) {\r\n\t\t\t\t\tyield buf;\r\n\t\t\t\t\tbuf = [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (buf.length) yield buf;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Streamをスライド分割\r\n\t * @param {Number} size\r\n\t * @param {Number} step\r\n\t * @returns {this}\r\n\t */\r\n\twindowed(size, step = size) {\r\n\t\treturn this._use(function* (iter) {\r\n\t\t\tconst buffer = [];\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tbuffer.push(item);\r\n\t\t\t\tif (buffer.length === size) {\r\n\t\t\t\t\tyield buffer.slice();\r\n\t\t\t\t\tbuffer.splice(0, step); // スライド\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// Iterator\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * Streamをイテレータ化\r\n\t * @returns {Iterator}\r\n\t */\r\n\t[Symbol.iterator]() {\r\n\t\treturn this._pipeline.reduce((iter, fn) => fn(iter), this._iter);\r\n\t}\r\n\r\n\t/**\r\n\t * Streamをイテレータ化(非同期)\r\n\t * @returns {AsyncIterator}\r\n\t */\r\n\t[Symbol.asyncIterator]() {\r\n\t\tlet iter = this._pipeline.reduce((i, fn) => fn(i), this._iter);\r\n\t\treturn {\r\n\t\t\tasync next() {\r\n\t\t\t\treturn Promise.resolve(iter.next());\r\n\t\t\t},\r\n\t\t};\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// End\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * StreamをforEach\r\n\t * @param {Function} fn\r\n\t */\r\n\tforEach(fn) {\r\n\t\tfor (const item of this) fn(item);\r\n\t}\r\n\r\n\t/**\r\n\t * Streamを配列化\r\n\t * @returns {V[]}\r\n\t */\r\n\ttoArray() {\r\n\t\treturn Array.from(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Streamをreduce\r\n\t * @param {Function} fn\r\n\t * @param {any} initial\r\n\t * @returns {any}\r\n\t */\r\n\treduce(fn, initial) {\r\n\t\tlet acc = initial;\r\n\t\tfor (const item of this) {\r\n\t\t\tacc = fn(acc, item);\r\n\t\t}\r\n\t\treturn acc;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamの要素数を取得\r\n\t * @returns {Number}\r\n\t */\r\n\tcount() {\r\n\t\tlet c = 0;\r\n\t\tfor (const _ of this) c++;\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamで条件を満たす要素があるか検査\r\n\t * @param {Function} fn\r\n\t * @returns {Boolean}\r\n\t */\r\n\tsome(fn) {\r\n\t\tfor (const item of this) {\r\n\t\t\tif (fn(item)) return true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamで全ての要素が条件を満たすか検査\r\n\t * @param {Function} fn\r\n\t * @returns {Boolean}\r\n\t */\r\n\tevery(fn) {\r\n\t\tfor (const item of this) {\r\n\t\t\tif (!fn(item)) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamから最初の要素を取得\r\n\t * @returns {any}\r\n\t */\r\n\tfindFirst() {\r\n\t\tfor (const item of this) return item;\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Streamから任意の要素を取得\r\n\t * @returns {any}\r\n\t */\r\n\tfindAny() {\r\n\t\treturn this.findFirst(); // 同義（非並列）\r\n\t}\r\n\r\n\t/**\r\n\t * Java Collectors 相当\r\n\t * @param {Function} collectorFn\r\n\t * @returns {any}\r\n\t */\r\n\tcollectWith(collectorFn) {\r\n\t\treturn collectorFn(this);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// mapTo\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * StreamをNumberStreamに変換\r\n\t * @param {Function} fn\r\n\t * @returns {NumberStreamType}\r\n\t */\r\n\tmapToNumber(fn) {\r\n\t\treturn this._convertToX(NumberStream, function* (iter) {\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tconst mapped = fn(item);\r\n\t\t\t\tif (typeof mapped !== \"number\") {\r\n\t\t\t\t\tthrow new TypeError(`mapToNumber() must return number. Got ${typeof mapped}`);\r\n\t\t\t\t}\r\n\t\t\t\tyield mapped;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * StreamをStringStreamに変換\r\n\t * @param {Function} fn\r\n\t * @returns {StringStream_forceRep}\r\n\t */\r\n\tmapToString(fn) {\r\n\t\treturn this._convertToX(StringStream, function* (iter) {\r\n\t\t\tfor (const item of iter) {\r\n\t\t\t\tconst mapped = fn(item);\r\n\t\t\t\tif (typeof mapped !== \"string\") {\r\n\t\t\t\t\tthrow new TypeError(`mapToString() must return string. Got ${typeof mapped}`);\r\n\t\t\t\t}\r\n\t\t\t\tyield mapped;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * StreamをEntryStreamに変換\r\n\t * @param {Function} fn\r\n\t * @returns {EntryStreamType}\r\n\t */\r\n\tmapToEntry(fn) {\r\n\t\treturn this._convertToX(\r\n\t\t\tEntryStream,\r\n\t\t\tfunction* (iter) {\r\n\t\t\t\tfor (const item of iter) {\r\n\t\t\t\t\tconst entry = fn(item);\r\n\t\t\t\t\tif (!Array.isArray(entry) || entry.length !== 2) {\r\n\t\t\t\t\t\tthrow new TypeError(`mapToEntry() must return [key, value] pair. Got: ${entry}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tyield entry;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tAny,\r\n\t\t\tAny\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * StreamをAsyncStreamに変換\r\n\t * @param {Function} fn\r\n\t * @returns {AsyncStreamType}\r\n\t */\r\n\tmapToAsync(fn) {\r\n\t\tconst input = this.flattenPipeline();\r\n\t\tconst sourceIterable = input._pipeline[0](input._iter); // 実行（同期 generator）\r\n\r\n\t\t// AsyncStream に渡す非同期イテレータを構築\r\n\t\tconst asyncIterable = (async function* () {\r\n\t\t\tfor (const item of sourceIterable) {\r\n\t\t\t\tyield await fn(item);\r\n\t\t\t}\r\n\t\t})();\r\n\r\n\t\treturn new AsyncStream(asyncIterable);\r\n\t}\r\n\r\n\t// ==================================================\r\n\t// to\r\n\t// ==================================================\r\n\r\n\t/**\r\n\t * StreamをHashSetに変換\r\n\t * @param {Function} [ValueType]\r\n\t * @returns {HashSetType}\r\n\t */\r\n\ttoHashSet(ValueType = this._ValueType) {\r\n\t\tconst set = new HashSet(ValueType);\r\n\t\tfor (const item of this) set.add(item);\r\n\t\treturn set;\r\n\t}\r\n\r\n\t/**\r\n\t * 文字列に変換する\r\n\t * @returns {String}\r\n\t */\r\n\ttoString() {\r\n\t\treturn `${this.constructor.name}<${TypeChecker.typeNames(this._ValueType)}>`;\r\n\t}\r\n}\r\n\r\nmodule.exports = Stream;\r\n",
    "const JavaLibraryScriptCore = require(\"../../libs/sys/JavaLibraryScriptCore.js\");\nconst TypeChecker = require(\"../../libs/TypeChecker.js\");\nconst StreamInterface = require(\"./StreamInterface.js\");\n\nlet Stream, NumberStream, StringStream, EntryStream, AsyncStream;\nfunction init() {\n\tif (Stream) return;\n\tStream = require(\"./Stream.js\");\n\tNumberStream = require(\"./NumberStream.js\");\n\tStringStream = require(\"./StringStream.js\");\n\tEntryStream = require(\"./EntryStream.js\");\n\tAsyncStream = require(\"./AsyncStream.js\");\n}\n\n/**\n * Streamの型チェック\n * @extends {JavaLibraryScriptCore}\n * @class\n */\nclass StreamChecker extends JavaLibraryScriptCore {\n\t/**\n\t * TypeをStreamに変換する\n\t * @param {Function} expected\n\t * @returns {StreamInterface}\n\t */\n\tstatic typeToStream(expected) {\n\t\tinit();\n\t\tif (expected == null) return Stream;\n\t\tif (expected === String) return StringStream;\n\t\tif (expected === Number) return NumberStream;\n\t\tif (expected === Map) return EntryStream;\n\t\tif (expected === Promise) return AsyncStream;\n\t\treturn Stream;\n\t}\n\n\t/**\n\t * StreamをTypeに変換する\n\t * @param {StreamInterface} stream\n\t * @returns {Function}\n\t * @static\n\t */\n\tstatic streamToType(stream) {\n\t\tinit();\n\t\t// Stream継承\n\t\tif (stream instanceof StringStream) return String;\n\t\tif (stream instanceof NumberStream) return Number;\n\t\tif (stream instanceof EntryStream) return Map;\n\t\t// StreamInterface継承\n\t\tif (stream instanceof AsyncStream) return Promise;\n\t\tif (stream instanceof Stream) return TypeChecker.Any;\n\t\treturn null;\n\t}\n}\n\nmodule.exports = StreamChecker;\n",
    "const JavaLibraryScriptCore = require(\"../../libs/sys/JavaLibraryScriptCore.js\");\nconst Interface = require(\"../../base/Interface\");\n\n/**\n * Streamの基底クラス\n * @extends {JavaLibraryScriptCore}\n * @class\n * @abstract\n */\nclass StreamInterface extends JavaLibraryScriptCore {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nmodule.exports = Interface.convert(StreamInterface, {\n\tmap: {\n\t\targs: [Function],\n\t\treturns: StreamInterface,\n\t},\n\tfilter: {\n\t\targs: [Function],\n\t\treturns: StreamInterface,\n\t},\n\tflatMap: {\n\t\targs: [Function],\n\t\treturns: StreamInterface,\n\t},\n\t//\n\tforEach: {\n\t\targs: [[Function, Promise]],\n\t\treturns: [undefined, Promise],\n\t},\n});\n",
    "const Stream = require(\"./Stream.js\");\n\n/**\n * 文字列専用Stream (LazyList)\n * @template V\n * @extends {Stream}\n * @class\n */\nclass StringStream extends Stream {\n\t/**\n\t * @param {Iterable<V>} source\n\t */\n\tconstructor(source) {\n\t\tsuper(source, String);\n\n\t\tthis.mapToString = undefined;\n\t}\n\n\t/**\n\t * 文字列連結\n\t * @param {string} separator\n\t * @returns {string}\n\t */\n\tjoin(separator = \" \") {\n\t\treturn Array.from(this).join(separator);\n\t}\n\n\t/**\n\t * 文字列を結合\n\t * @returns {string}\n\t */\n\tconcatAll() {\n\t\treturn this.join(\"\");\n\t}\n\n\t/**\n\t * 最長の文字列を返す\n\t * @returns {string}\n\t */\n\tlongest() {\n\t\tlet max = \"\";\n\t\tfor (const str of this) {\n\t\t\tif (str.length > max.length) max = str;\n\t\t}\n\t\treturn max || null;\n\t}\n\n\t/**\n\t * 最短の文字列を返す\n\t * @returns {string}\n\t */\n\tshortest() {\n\t\tlet min = null;\n\t\tfor (const str of this) {\n\t\t\tif (min === null || str.length < min.length) min = str;\n\t\t}\n\t\treturn min || null;\n\t}\n}\n\nmodule.exports = StringStream;\n",
    "module.exports = {\n    AsyncStream: require(\"./AsyncStream.js\"),\n    EntryStream: require(\"./EntryStream.js\"),\n    NumberStream: require(\"./NumberStream.js\"),\n    Stream: require(\"./Stream.js\"),\n    StreamChecker: require(\"./StreamChecker.js\"),\n    StreamInterface: require(\"./StreamInterface.js\"),\n    StringStream: require(\"./StringStream.js\")\n};\n"
  ]
}